/* tslint:disable */
/* eslint-disable */
/**
 * Quiika API
 * Production REST API for Quiika Application.  ## Authentication This API uses JWT Bearer token authentication. Include the token in the Authorization header as: `Authorization: Bearer <your-token>`  ## Rate Limiting API is rate limited. Check response headers for rate limit information.  ## Error Handling All errors follow a consistent format with appropriate HTTP status codes. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface ApiKeyResponse {
    'challenge'?: string;
    'apiKey'?: string;
}
export interface AuditLogDto {
    'id'?: number;
    'timestamp'?: string;
    'adminUserId'?: number;
    'actionType'?: AuditLogDtoActionTypeEnum;
    'targetEntity'?: string;
    'targetEntityId'?: string;
    'details'?: string;
}

export const AuditLogDtoActionTypeEnum = {
    UserStatusUpdate: 'USER_STATUS_UPDATE',
    UserRoleUpdate: 'USER_ROLE_UPDATE',
    QuidCreate: 'QUID_CREATE',
    QuidStatusUpdate: 'QUID_STATUS_UPDATE',
    TransactionRefund: 'TRANSACTION_REFUND',
    WithdrawalApprove: 'WITHDRAWAL_APPROVE',
    WithdrawalReject: 'WITHDRAWAL_REJECT',
    InviteCreate: 'INVITE_CREATE',
    InviteResend: 'INVITE_RESEND',
    InviteDelete: 'INVITE_DELETE'
} as const;

export type AuditLogDtoActionTypeEnum = typeof AuditLogDtoActionTypeEnum[keyof typeof AuditLogDtoActionTypeEnum];

export interface BankDto {
    /**
     * Bank name
     */
    'name'?: string;
    /**
     * Bank code
     */
    'code'?: string;
}
export interface ClaimAttemptDto {
    'id'?: number;
    'userId'?: string;
    'deviceId'?: string;
    'ipAddress'?: string;
    'createdAt'?: string;
}
/**
 * Details for the new Quid.
 */
export interface CreateQuidRequest {
    'amount'?: number;
    'currency': string;
}
export interface DashboardMetricsDto {
    'totalUsers'?: MetricLong;
    'totalQuids'?: MetricLong;
    'totalQuidValue'?: MetricBigDecimal;
    'totalTransactions'?: MetricLong;
    'totalSuccessfulTransactionValue'?: MetricBigDecimal;
    'withdrawalRequestsByStatus'?: { [key: string]: number; };
    'totalApprovedWithdrawalValue'?: MetricBigDecimal;
    'systemHealth'?: { [key: string]: any; };
}
/**
 * Client\'s public key and session ID
 */
export interface EcdhCompleteRequest {
    'clientPublicKey'?: string;
    'sessionId'?: string;
}
export interface EcdhInitResponse {
    'sessionId'?: string;
    'serverPublicKey'?: string;
}
/**
 * The user\'s email address.
 */
export interface ForgotPasswordRequest {
    'email': string;
}
/**
 * Payment initialization payload
 */
export interface InitializePaymentRequest {
    'amount'?: number;
    'email'?: string;
    'reference'?: string;
    'callbackUrl'?: string;
}
export interface InitializePaymentResponse {
    'authorizationUrl'?: string;
    'accessCode'?: string;
    'reference'?: string;
}
export interface InviteDto {
    'id'?: number;
    'email'?: string;
    'status'?: InviteDtoStatusEnum;
    'expiresAt'?: string;
}

export const InviteDtoStatusEnum = {
    Pending: 'PENDING',
    Accepted: 'ACCEPTED',
    Expired: 'EXPIRED'
} as const;

export type InviteDtoStatusEnum = typeof InviteDtoStatusEnum[keyof typeof InviteDtoStatusEnum];

export interface InviteRequest {
    'email': string;
    'roleName': string;
}
export interface JwtAuthenticationResponse {
    'accessToken'?: string;
    'refreshToken'?: string;
    'sessionId'?: string;
    'user'?: UserDto;
}
export interface Link {
    'href'?: string;
    'templated'?: boolean;
}
/**
 * User credentials for login.
 */
export interface LoginRequest {
    'email': string;
    'password': string;
}
export interface MetricBigDecimal {
    'value'?: number;
    'growth'?: number;
}
export interface MetricLong {
    'value'?: number;
    'growth'?: number;
}
export interface Page {
    'totalElements'?: number;
    'totalPages'?: number;
    'pageable'?: PageableObject;
    'sort'?: SortObject;
    'first'?: boolean;
    'last'?: boolean;
    'number'?: number;
    'numberOfElements'?: number;
    'size'?: number;
    'content'?: Array<any>;
    'empty'?: boolean;
}
export interface PageAuditLogDto {
    'totalElements'?: number;
    'totalPages'?: number;
    'pageable'?: PageableObject;
    'sort'?: SortObject;
    'first'?: boolean;
    'last'?: boolean;
    'number'?: number;
    'numberOfElements'?: number;
    'size'?: number;
    'content'?: Array<AuditLogDto>;
    'empty'?: boolean;
}
export interface PageClaimAttemptDto {
    'totalElements'?: number;
    'totalPages'?: number;
    'pageable'?: PageableObject;
    'sort'?: SortObject;
    'first'?: boolean;
    'last'?: boolean;
    'number'?: number;
    'numberOfElements'?: number;
    'size'?: number;
    'content'?: Array<ClaimAttemptDto>;
    'empty'?: boolean;
}
export interface PageQuidDto {
    'totalElements'?: number;
    'totalPages'?: number;
    'pageable'?: PageableObject;
    'sort'?: SortObject;
    'first'?: boolean;
    'last'?: boolean;
    'number'?: number;
    'numberOfElements'?: number;
    'size'?: number;
    'content'?: Array<QuidDto>;
    'empty'?: boolean;
}
export interface PageTransactionDto {
    'totalElements'?: number;
    'totalPages'?: number;
    'pageable'?: PageableObject;
    'sort'?: SortObject;
    'first'?: boolean;
    'last'?: boolean;
    'number'?: number;
    'numberOfElements'?: number;
    'size'?: number;
    'content'?: Array<TransactionDto>;
    'empty'?: boolean;
}
export interface PageWinnerDto {
    'totalElements'?: number;
    'totalPages'?: number;
    'pageable'?: PageableObject;
    'sort'?: SortObject;
    'first'?: boolean;
    'last'?: boolean;
    'number'?: number;
    'numberOfElements'?: number;
    'size'?: number;
    'content'?: Array<WinnerDto>;
    'empty'?: boolean;
}
export interface PageWithdrawalRequestDto {
    'totalElements'?: number;
    'totalPages'?: number;
    'pageable'?: PageableObject;
    'sort'?: SortObject;
    'first'?: boolean;
    'last'?: boolean;
    'number'?: number;
    'numberOfElements'?: number;
    'size'?: number;
    'content'?: Array<WithdrawalRequestDto>;
    'empty'?: boolean;
}
export interface Pageable {
    'page'?: number;
    'size'?: number;
    'sort'?: Array<string>;
}
export interface PageableObject {
    'paged'?: boolean;
    'pageNumber'?: number;
    'pageSize'?: number;
    'sort'?: SortObject;
    'unpaged'?: boolean;
    'offset'?: number;
}
export interface Quid {
    'id'?: number;
    'quid'?: string;
    'amount'?: number;
    'currency'?: string;
    'status'?: QuidStatusEnum;
    'blocked'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
}

export const QuidStatusEnum = {
    Active: 'ACTIVE',
    Split: 'SPLIT',
    Claimed: 'CLAIMED',
    Blocked: 'BLOCKED',
    Expired: 'EXPIRED',
    Conflicted: 'CONFLICTED'
} as const;

export type QuidStatusEnum = typeof QuidStatusEnum[keyof typeof QuidStatusEnum];

export interface QuidClaimResponse {
    'quid'?: Quid;
    'allowAccess'?: boolean;
    'message'?: string;
    'accessKey'?: string;
}
export interface QuidDetailDto {
    'quid'?: QuidDto;
    'rule'?: RuleDto;
    'claimAttempts'?: Array<ClaimAttemptDto>;
    'winners'?: Array<WinnerDto>;
}
export interface QuidDto {
    'id'?: number;
    'quid'?: string;
    'amount'?: number;
    'currency'?: string;
    'status'?: QuidDtoStatusEnum;
    'blocked'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
}

export const QuidDtoStatusEnum = {
    Active: 'ACTIVE',
    Split: 'SPLIT',
    Claimed: 'CLAIMED',
    Blocked: 'BLOCKED',
    Expired: 'EXPIRED',
    Conflicted: 'CONFLICTED'
} as const;

export type QuidDtoStatusEnum = typeof QuidDtoStatusEnum[keyof typeof QuidDtoStatusEnum];

/**
 * The new status for the Quid.
 */
export interface QuidStatusDto {
    'status'?: QuidStatusDtoStatusEnum;
}

export const QuidStatusDtoStatusEnum = {
    Active: 'ACTIVE',
    Split: 'SPLIT',
    Claimed: 'CLAIMED',
    Blocked: 'BLOCKED',
    Expired: 'EXPIRED',
    Conflicted: 'CONFLICTED'
} as const;

export type QuidStatusDtoStatusEnum = typeof QuidStatusDtoStatusEnum[keyof typeof QuidStatusDtoStatusEnum];

/**
 * The new status for the Quid.
 */
export interface QuidStatusUpdateRequest {
    'status': QuidStatusUpdateRequestStatusEnum;
}

export const QuidStatusUpdateRequestStatusEnum = {
    Active: 'ACTIVE',
    Split: 'SPLIT',
    Claimed: 'CLAIMED',
    Blocked: 'BLOCKED',
    Expired: 'EXPIRED',
    Conflicted: 'CONFLICTED'
} as const;

export type QuidStatusUpdateRequestStatusEnum = typeof QuidStatusUpdateRequestStatusEnum[keyof typeof QuidStatusUpdateRequestStatusEnum];

export interface QuiikaErrorResponse {
    'message'?: any;
    'status'?: QuiikaErrorResponseStatusEnum;
}

export const QuiikaErrorResponseStatusEnum = {
    _100Continue: '100 CONTINUE',
    _101SwitchingProtocols: '101 SWITCHING_PROTOCOLS',
    _102Processing: '102 PROCESSING',
    _103EarlyHints: '103 EARLY_HINTS',
    _103Checkpoint: '103 CHECKPOINT',
    _200Ok: '200 OK',
    _201Created: '201 CREATED',
    _202Accepted: '202 ACCEPTED',
    _203NonAuthoritativeInformation: '203 NON_AUTHORITATIVE_INFORMATION',
    _204NoContent: '204 NO_CONTENT',
    _205ResetContent: '205 RESET_CONTENT',
    _206PartialContent: '206 PARTIAL_CONTENT',
    _207MultiStatus: '207 MULTI_STATUS',
    _208AlreadyReported: '208 ALREADY_REPORTED',
    _226ImUsed: '226 IM_USED',
    _300MultipleChoices: '300 MULTIPLE_CHOICES',
    _301MovedPermanently: '301 MOVED_PERMANENTLY',
    _302Found: '302 FOUND',
    _302MovedTemporarily: '302 MOVED_TEMPORARILY',
    _303SeeOther: '303 SEE_OTHER',
    _304NotModified: '304 NOT_MODIFIED',
    _305UseProxy: '305 USE_PROXY',
    _307TemporaryRedirect: '307 TEMPORARY_REDIRECT',
    _308PermanentRedirect: '308 PERMANENT_REDIRECT',
    _400BadRequest: '400 BAD_REQUEST',
    _401Unauthorized: '401 UNAUTHORIZED',
    _402PaymentRequired: '402 PAYMENT_REQUIRED',
    _403Forbidden: '403 FORBIDDEN',
    _404NotFound: '404 NOT_FOUND',
    _405MethodNotAllowed: '405 METHOD_NOT_ALLOWED',
    _406NotAcceptable: '406 NOT_ACCEPTABLE',
    _407ProxyAuthenticationRequired: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408RequestTimeout: '408 REQUEST_TIMEOUT',
    _409Conflict: '409 CONFLICT',
    _410Gone: '410 GONE',
    _411LengthRequired: '411 LENGTH_REQUIRED',
    _412PreconditionFailed: '412 PRECONDITION_FAILED',
    _413PayloadTooLarge: '413 PAYLOAD_TOO_LARGE',
    _413RequestEntityTooLarge: '413 REQUEST_ENTITY_TOO_LARGE',
    _414UriTooLong: '414 URI_TOO_LONG',
    _414RequestUriTooLong: '414 REQUEST_URI_TOO_LONG',
    _415UnsupportedMediaType: '415 UNSUPPORTED_MEDIA_TYPE',
    _416RequestedRangeNotSatisfiable: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417ExpectationFailed: '417 EXPECTATION_FAILED',
    _418IAmATeapot: '418 I_AM_A_TEAPOT',
    _419InsufficientSpaceOnResource: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420MethodFailure: '420 METHOD_FAILURE',
    _421DestinationLocked: '421 DESTINATION_LOCKED',
    _422UnprocessableEntity: '422 UNPROCESSABLE_ENTITY',
    _423Locked: '423 LOCKED',
    _424FailedDependency: '424 FAILED_DEPENDENCY',
    _425TooEarly: '425 TOO_EARLY',
    _426UpgradeRequired: '426 UPGRADE_REQUIRED',
    _428PreconditionRequired: '428 PRECONDITION_REQUIRED',
    _429TooManyRequests: '429 TOO_MANY_REQUESTS',
    _431RequestHeaderFieldsTooLarge: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451UnavailableForLegalReasons: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500InternalServerError: '500 INTERNAL_SERVER_ERROR',
    _501NotImplemented: '501 NOT_IMPLEMENTED',
    _502BadGateway: '502 BAD_GATEWAY',
    _503ServiceUnavailable: '503 SERVICE_UNAVAILABLE',
    _504GatewayTimeout: '504 GATEWAY_TIMEOUT',
    _505HttpVersionNotSupported: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506VariantAlsoNegotiates: '506 VARIANT_ALSO_NEGOTIATES',
    _507InsufficientStorage: '507 INSUFFICIENT_STORAGE',
    _508LoopDetected: '508 LOOP_DETECTED',
    _509BandwidthLimitExceeded: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510NotExtended: '510 NOT_EXTENDED',
    _511NetworkAuthenticationRequired: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type QuiikaErrorResponseStatusEnum = typeof QuiikaErrorResponseStatusEnum[keyof typeof QuiikaErrorResponseStatusEnum];

export interface QuiikaResponse {
    'message'?: string;
    'accessKey'?: string;
}
/**
 * User registration details.
 */
export interface RegisterRequest {
    'firstName': string;
    'lastName': string;
    'password': string;
    'inviteToken': string;
}
/**
 * Reason for rejecting the withdrawal.
 */
export interface RejectWithdrawalRequestDto {
    'reason': string;
}
/**
 * Password reset token and new password.
 */
export interface ResetPasswordRequest {
    'token': string;
    'newPassword': string;
}
/**
 * Request and response for bank account name resolution
 */
export interface ResolveBank {
    /**
     * Bank account number
     */
    'accountNumber': string;
    /**
     * Bank code (e.g., Paystack bank code)
     */
    'bankCode': string;
    /**
     * Resolved account holder\'s name
     */
    'accountName'?: string;
}
export interface Rule {
    'id'?: number;
    'createdAt'?: string;
    'updatedAt'?: string;
    'quid'?: Quid;
    'nthPerson'?: number;
    'startTime'?: string;
    'endTime'?: string;
    'totalSplits'?: number;
    'totalAmount'?: number;
    'splits'?: Array<Split>;
}
/**
 * The rule data to create.
 */
export interface RuleDTO {
    'quid'?: string;
    'nthPerson'?: number;
    'totalSplits'?: number;
    'startTime'?: string;
    'endTime'?: string;
    'splits'?: Array<SplitDTO>;
}
export interface RuleDto {
    'id'?: number;
    'nthPerson'?: number;
    'startTime'?: string;
    'endTime'?: string;
    'totalSplits'?: number;
    'totalAmount'?: number;
}
export interface SessionCountResponse {
    'activeSessions'?: number;
}
export interface SortObject {
    'sorted'?: boolean;
    'unsorted'?: boolean;
    'empty'?: boolean;
}
export interface Split {
    'id'?: number;
    'amount'?: number;
    'percentage'?: number;
    'rule'?: Rule;
}
export interface SplitDTO {
    'percentage'?: number;
}
export interface TimeSeriesDataDto {
    'userSignups'?: Array<TimeSeriesDataPoint>;
    'quidsCreated'?: Array<TimeSeriesDataPoint>;
    'transactionsCompleted'?: Array<TimeSeriesDataPoint>;
    'withdrawalsProcessed'?: Array<TimeSeriesDataPoint>;
}
export interface TimeSeriesDataPoint {
    'date'?: string;
    'value'?: number;
}
export interface Transaction {
    'id'?: number;
    'email'?: string;
    'amount'?: number;
    'currency'?: string;
    'quid'?: string;
    'reference'?: string;
    'transactionId'?: string;
    'status'?: TransactionStatusEnum;
    'paymentProvider'?: string;
    'blocked'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
}

export const TransactionStatusEnum = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Success: 'SUCCESS',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Refunded: 'REFUNDED',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    UnknownStatus: 'UNKNOWN_STATUS'
} as const;

export type TransactionStatusEnum = typeof TransactionStatusEnum[keyof typeof TransactionStatusEnum];

export interface TransactionDetailDto {
    'id'?: number;
    'email'?: string;
    'amount'?: number;
    'currency'?: string;
    'quid'?: string;
    'reference'?: string;
    'transactionId'?: string;
    'status'?: TransactionDetailDtoStatusEnum;
    'paymentProvider'?: string;
    'blocked'?: boolean;
    'createdAt'?: string;
    'updatedAt'?: string;
}

export const TransactionDetailDtoStatusEnum = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Success: 'SUCCESS',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Refunded: 'REFUNDED',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    UnknownStatus: 'UNKNOWN_STATUS'
} as const;

export type TransactionDetailDtoStatusEnum = typeof TransactionDetailDtoStatusEnum[keyof typeof TransactionDetailDtoStatusEnum];

export interface TransactionDto {
    'quid'?: string;
    'email'?: string;
    'amount'?: number;
    'sessionId'?: string;
    'authorizationUrl'?: string;
    'transactionId'?: string;
    'status'?: TransactionDtoStatusEnum;
    'blocked'?: boolean;
}

export const TransactionDtoStatusEnum = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Success: 'SUCCESS',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Refunded: 'REFUNDED',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    UnknownStatus: 'UNKNOWN_STATUS'
} as const;

export type TransactionDtoStatusEnum = typeof TransactionDtoStatusEnum[keyof typeof TransactionDtoStatusEnum];

/**
 * User details for admin operations
 */
export interface UserDto {
    /**
     * Unique user ID
     */
    'id'?: number;
    /**
     * User email address
     */
    'email'?: string;
    /**
     * First name
     */
    'firstName'?: string;
    /**
     * Last name
     */
    'lastName'?: string;
    /**
     * Is account enabled?
     */
    'enabled'?: boolean;
    /**
     * Is account locked?
     */
    'locked'?: boolean;
    /**
     * User role
     */
    'role'?: UserDtoRoleEnum;
    /**
     * Account creation timestamp
     */
    'createdAt'?: string;
    /**
     * Last update timestamp
     */
    'updatedAt'?: string;
}

export const UserDtoRoleEnum = {
    User: 'USER',
    Admin: 'ADMIN',
    Moderator: 'MODERATOR'
} as const;

export type UserDtoRoleEnum = typeof UserDtoRoleEnum[keyof typeof UserDtoRoleEnum];

/**
 * New role to assign
 */
export interface UserRoleUpdateDto {
    'role': UserRoleUpdateDtoRoleEnum;
}

export const UserRoleUpdateDtoRoleEnum = {
    User: 'USER',
    Admin: 'ADMIN',
    Moderator: 'MODERATOR'
} as const;

export type UserRoleUpdateDtoRoleEnum = typeof UserRoleUpdateDtoRoleEnum[keyof typeof UserRoleUpdateDtoRoleEnum];

export interface UserSessionDetails {
    'sessionId'?: string;
    'ipAddress'?: string;
    'userAgent'?: string;
    'loginTime'?: number;
    'lastAccessed'?: number;
    'email'?: string;
    'location'?: string;
    'deviceType'?: string;
    'sessionDuration'?: number;
    'inactivityDuration'?: number;
}
/**
 * Status update action
 */
export interface UserStatusUpdateDto {
    'action': UserStatusUpdateDtoActionEnum;
}

export const UserStatusUpdateDtoActionEnum = {
    Activate: 'ACTIVATE',
    Block: 'BLOCK',
    Deactivate: 'DEACTIVATE'
} as const;

export type UserStatusUpdateDtoActionEnum = typeof UserStatusUpdateDtoActionEnum[keyof typeof UserStatusUpdateDtoActionEnum];

export interface WinnerDto {
    'id'?: number;
    'amount'?: number;
    'userId'?: string;
    'order'?: number;
    'claimedAt'?: string;
}
export interface WithdrawalRequest {
    'id'?: number;
    'quid'?: string;
    'transaction'?: Transaction;
    'accountName'?: string;
    'accountNumber'?: string;
    'amount'?: number;
    'bank'?: string;
    'bankCode'?: string;
    'reference'?: string;
    'currency'?: WithdrawalRequestCurrencyEnum;
    'status'?: WithdrawalRequestStatusEnum;
    'rejectionReason'?: string;
    'accessKey'?: string;
    'createdAt'?: string;
    'updatedAt'?: string;
}

export const WithdrawalRequestCurrencyEnum = {
    Ghs: 'GHS',
    Ngn: 'NGN',
    Zar: 'ZAR',
    Kes: 'KES'
} as const;

export type WithdrawalRequestCurrencyEnum = typeof WithdrawalRequestCurrencyEnum[keyof typeof WithdrawalRequestCurrencyEnum];
export const WithdrawalRequestStatusEnum = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Success: 'SUCCESS',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Refunded: 'REFUNDED',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    UnknownStatus: 'UNKNOWN_STATUS'
} as const;

export type WithdrawalRequestStatusEnum = typeof WithdrawalRequestStatusEnum[keyof typeof WithdrawalRequestStatusEnum];

export interface WithdrawalRequestDetailDto {
    'id'?: number;
    'email'?: string;
    'amount'?: number;
    'currency'?: WithdrawalRequestDetailDtoCurrencyEnum;
    'status'?: WithdrawalRequestDetailDtoStatusEnum;
    'reference'?: string;
    'createdAt'?: string;
    'updatedAt'?: string;
    'bank'?: string;
    'accountNumber'?: string;
    'accountName'?: string;
    'quid'?: string;
    'accessKey'?: string;
    'rejectionReason'?: string;
}

export const WithdrawalRequestDetailDtoCurrencyEnum = {
    Ghs: 'GHS',
    Ngn: 'NGN',
    Zar: 'ZAR',
    Kes: 'KES'
} as const;

export type WithdrawalRequestDetailDtoCurrencyEnum = typeof WithdrawalRequestDetailDtoCurrencyEnum[keyof typeof WithdrawalRequestDetailDtoCurrencyEnum];
export const WithdrawalRequestDetailDtoStatusEnum = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Success: 'SUCCESS',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Refunded: 'REFUNDED',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    UnknownStatus: 'UNKNOWN_STATUS'
} as const;

export type WithdrawalRequestDetailDtoStatusEnum = typeof WithdrawalRequestDetailDtoStatusEnum[keyof typeof WithdrawalRequestDetailDtoStatusEnum];

export interface WithdrawalRequestDto {
    'id'?: number;
    'email'?: string;
    'amount'?: number;
    'currency'?: WithdrawalRequestDtoCurrencyEnum;
    'status'?: WithdrawalRequestDtoStatusEnum;
    'reference'?: string;
    'createdAt'?: string;
    'bank'?: string;
    'accountNumber'?: string;
    'accountName'?: string;
}

export const WithdrawalRequestDtoCurrencyEnum = {
    Ghs: 'GHS',
    Ngn: 'NGN',
    Zar: 'ZAR',
    Kes: 'KES'
} as const;

export type WithdrawalRequestDtoCurrencyEnum = typeof WithdrawalRequestDtoCurrencyEnum[keyof typeof WithdrawalRequestDtoCurrencyEnum];
export const WithdrawalRequestDtoStatusEnum = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Success: 'SUCCESS',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Refunded: 'REFUNDED',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    UnknownStatus: 'UNKNOWN_STATUS'
} as const;

export type WithdrawalRequestDtoStatusEnum = typeof WithdrawalRequestDtoStatusEnum[keyof typeof WithdrawalRequestDtoStatusEnum];

/**
 * The data to update the withdrawal request with.
 */
export interface WithdrawalUpdateDto {
    'quid': string;
    'status': WithdrawalUpdateDtoStatusEnum;
}

export const WithdrawalUpdateDtoStatusEnum = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Success: 'SUCCESS',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Refunded: 'REFUNDED',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    UnknownStatus: 'UNKNOWN_STATUS'
} as const;

export type WithdrawalUpdateDtoStatusEnum = typeof WithdrawalUpdateDtoStatusEnum[keyof typeof WithdrawalUpdateDtoStatusEnum];


/**
 * ActuatorApi - axios parameter creator
 */
export const ActuatorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Actuator web endpoint \'health\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actuator/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actuator root web endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        links: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actuator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actuator web endpoint \'metrics\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNames: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actuator/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actuator web endpoint \'metrics-requiredMetricName\'
         * @param {string} requiredMetricName 
         * @param {string} [tag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metric: async (requiredMetricName: string, tag?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requiredMetricName' is not null or undefined
            assertParamExists('metric', 'requiredMetricName', requiredMetricName)
            const localVarPath = `/actuator/metrics/{requiredMetricName}`
                .replace(`{${"requiredMetricName"}}`, encodeURIComponent(String(requiredMetricName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actuator web endpoint \'prometheus\'
         * @param {ScrapeFormatEnum} [format] 
         * @param {string} [includedNames] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scrape: async (format?: ScrapeFormatEnum, includedNames?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actuator/prometheus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (includedNames !== undefined) {
                localVarQueryParameter['includedNames'] = includedNames;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActuatorApi - functional programming interface
 */
export const ActuatorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActuatorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Actuator web endpoint \'health\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async health(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.health(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActuatorApi.health']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actuator root web endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async links(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: { [key: string]: Link; }; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.links(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActuatorApi.links']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actuator web endpoint \'metrics\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNames(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listNames(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActuatorApi.listNames']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actuator web endpoint \'metrics-requiredMetricName\'
         * @param {string} requiredMetricName 
         * @param {string} [tag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metric(requiredMetricName: string, tag?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metric(requiredMetricName, tag, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActuatorApi.metric']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actuator web endpoint \'prometheus\'
         * @param {ScrapeFormatEnum} [format] 
         * @param {string} [includedNames] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scrape(format?: ScrapeFormatEnum, includedNames?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scrape(format, includedNames, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActuatorApi.scrape']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActuatorApi - factory interface
 */
export const ActuatorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActuatorApiFp(configuration)
    return {
        /**
         * 
         * @summary Actuator web endpoint \'health\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.health(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actuator root web endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        links(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: { [key: string]: Link; }; }> {
            return localVarFp.links(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actuator web endpoint \'metrics\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNames(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.listNames(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actuator web endpoint \'metrics-requiredMetricName\'
         * @param {ActuatorApiMetricRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metric(requestParameters: ActuatorApiMetricRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.metric(requestParameters.requiredMetricName, requestParameters.tag, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actuator web endpoint \'prometheus\'
         * @param {ActuatorApiScrapeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scrape(requestParameters: ActuatorApiScrapeRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.scrape(requestParameters.format, requestParameters.includedNames, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActuatorApi - interface
 */
export interface ActuatorApiInterface {
    /**
     * 
     * @summary Actuator web endpoint \'health\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    health(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Actuator root web endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    links(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: { [key: string]: Link; }; }>;

    /**
     * 
     * @summary Actuator web endpoint \'metrics\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listNames(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Actuator web endpoint \'metrics-requiredMetricName\'
     * @param {ActuatorApiMetricRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    metric(requestParameters: ActuatorApiMetricRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Actuator web endpoint \'prometheus\'
     * @param {ActuatorApiScrapeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scrape(requestParameters?: ActuatorApiScrapeRequest, options?: RawAxiosRequestConfig): AxiosPromise<object>;

}

/**
 * Request parameters for metric operation in ActuatorApi.
 */
export interface ActuatorApiMetricRequest {
    readonly requiredMetricName: string

    readonly tag?: string
}

/**
 * Request parameters for scrape operation in ActuatorApi.
 */
export interface ActuatorApiScrapeRequest {
    readonly format?: ScrapeFormatEnum

    readonly includedNames?: string
}

/**
 * ActuatorApi - object-oriented interface
 */
export class ActuatorApi extends BaseAPI implements ActuatorApiInterface {
    /**
     * 
     * @summary Actuator web endpoint \'health\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public health(options?: RawAxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).health(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actuator root web endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public links(options?: RawAxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).links(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actuator web endpoint \'metrics\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listNames(options?: RawAxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).listNames(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actuator web endpoint \'metrics-requiredMetricName\'
     * @param {ActuatorApiMetricRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public metric(requestParameters: ActuatorApiMetricRequest, options?: RawAxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).metric(requestParameters.requiredMetricName, requestParameters.tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actuator web endpoint \'prometheus\'
     * @param {ActuatorApiScrapeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public scrape(requestParameters: ActuatorApiScrapeRequest = {}, options?: RawAxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).scrape(requestParameters.format, requestParameters.includedNames, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ScrapeFormatEnum = {
    ContentType004: 'CONTENT_TYPE_004',
    ContentTypeOpenmetrics100: 'CONTENT_TYPE_OPENMETRICS_100',
    ContentTypeProtobuf: 'CONTENT_TYPE_PROTOBUF'
} as const;
export type ScrapeFormatEnum = typeof ScrapeFormatEnum[keyof typeof ScrapeFormatEnum];


/**
 * AdminDashboardApi - axios parameter creator
 */
export const AdminDashboardApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provides key metrics for the dashboard over a specified period.
         * @summary Get dashboard metrics
         * @param {GetDashboardMetricsPeriodEnum} period The period for which to retrieve metrics (WEEKLY, MONTHLY, YEARLY)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardMetrics: async (period: GetDashboardMetricsPeriodEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getDashboardMetrics', 'period', period)
            const localVarPath = `/admin/dashboard/metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides time series data for key metrics over a specified period.
         * @summary Get dashboard time series data
         * @param {GetDashboardTimeSeriesPeriodEnum} period The period for which to retrieve time series data (WEEKLY, MONTHLY, YEARLY)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardTimeSeries: async (period: GetDashboardTimeSeriesPeriodEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'period' is not null or undefined
            assertParamExists('getDashboardTimeSeries', 'period', period)
            const localVarPath = `/admin/dashboard/timeseries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminDashboardApi - functional programming interface
 */
export const AdminDashboardApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminDashboardApiAxiosParamCreator(configuration)
    return {
        /**
         * Provides key metrics for the dashboard over a specified period.
         * @summary Get dashboard metrics
         * @param {GetDashboardMetricsPeriodEnum} period The period for which to retrieve metrics (WEEKLY, MONTHLY, YEARLY)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardMetrics(period: GetDashboardMetricsPeriodEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardMetricsDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardMetrics(period, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminDashboardApi.getDashboardMetrics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Provides time series data for key metrics over a specified period.
         * @summary Get dashboard time series data
         * @param {GetDashboardTimeSeriesPeriodEnum} period The period for which to retrieve time series data (WEEKLY, MONTHLY, YEARLY)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardTimeSeries(period: GetDashboardTimeSeriesPeriodEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimeSeriesDataDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardTimeSeries(period, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminDashboardApi.getDashboardTimeSeries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminDashboardApi - factory interface
 */
export const AdminDashboardApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminDashboardApiFp(configuration)
    return {
        /**
         * Provides key metrics for the dashboard over a specified period.
         * @summary Get dashboard metrics
         * @param {AdminDashboardApiGetDashboardMetricsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardMetrics(requestParameters: AdminDashboardApiGetDashboardMetricsRequest, options?: RawAxiosRequestConfig): AxiosPromise<DashboardMetricsDto> {
            return localVarFp.getDashboardMetrics(requestParameters.period, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides time series data for key metrics over a specified period.
         * @summary Get dashboard time series data
         * @param {AdminDashboardApiGetDashboardTimeSeriesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardTimeSeries(requestParameters: AdminDashboardApiGetDashboardTimeSeriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<TimeSeriesDataDto> {
            return localVarFp.getDashboardTimeSeries(requestParameters.period, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminDashboardApi - interface
 */
export interface AdminDashboardApiInterface {
    /**
     * Provides key metrics for the dashboard over a specified period.
     * @summary Get dashboard metrics
     * @param {AdminDashboardApiGetDashboardMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDashboardMetrics(requestParameters: AdminDashboardApiGetDashboardMetricsRequest, options?: RawAxiosRequestConfig): AxiosPromise<DashboardMetricsDto>;

    /**
     * Provides time series data for key metrics over a specified period.
     * @summary Get dashboard time series data
     * @param {AdminDashboardApiGetDashboardTimeSeriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDashboardTimeSeries(requestParameters: AdminDashboardApiGetDashboardTimeSeriesRequest, options?: RawAxiosRequestConfig): AxiosPromise<TimeSeriesDataDto>;

}

/**
 * Request parameters for getDashboardMetrics operation in AdminDashboardApi.
 */
export interface AdminDashboardApiGetDashboardMetricsRequest {
    /**
     * The period for which to retrieve metrics (WEEKLY, MONTHLY, YEARLY)
     */
    readonly period: GetDashboardMetricsPeriodEnum
}

/**
 * Request parameters for getDashboardTimeSeries operation in AdminDashboardApi.
 */
export interface AdminDashboardApiGetDashboardTimeSeriesRequest {
    /**
     * The period for which to retrieve time series data (WEEKLY, MONTHLY, YEARLY)
     */
    readonly period: GetDashboardTimeSeriesPeriodEnum
}

/**
 * AdminDashboardApi - object-oriented interface
 */
export class AdminDashboardApi extends BaseAPI implements AdminDashboardApiInterface {
    /**
     * Provides key metrics for the dashboard over a specified period.
     * @summary Get dashboard metrics
     * @param {AdminDashboardApiGetDashboardMetricsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDashboardMetrics(requestParameters: AdminDashboardApiGetDashboardMetricsRequest, options?: RawAxiosRequestConfig) {
        return AdminDashboardApiFp(this.configuration).getDashboardMetrics(requestParameters.period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provides time series data for key metrics over a specified period.
     * @summary Get dashboard time series data
     * @param {AdminDashboardApiGetDashboardTimeSeriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDashboardTimeSeries(requestParameters: AdminDashboardApiGetDashboardTimeSeriesRequest, options?: RawAxiosRequestConfig) {
        return AdminDashboardApiFp(this.configuration).getDashboardTimeSeries(requestParameters.period, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetDashboardMetricsPeriodEnum = {
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Yearly: 'YEARLY'
} as const;
export type GetDashboardMetricsPeriodEnum = typeof GetDashboardMetricsPeriodEnum[keyof typeof GetDashboardMetricsPeriodEnum];
export const GetDashboardTimeSeriesPeriodEnum = {
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Yearly: 'YEARLY'
} as const;
export type GetDashboardTimeSeriesPeriodEnum = typeof GetDashboardTimeSeriesPeriodEnum[keyof typeof GetDashboardTimeSeriesPeriodEnum];


/**
 * AdminLoggingApi - axios parameter creator
 */
export const AdminLoggingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Downloads the application log file. Only accessible by admins.
         * @summary Download application log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadApplicationLog: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/logs/application`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of audit logs with optional filters.
         * @summary Get audit logs
         * @param {Pageable} pageable 
         * @param {number} [adminUserId] Filter by admin user ID
         * @param {GetAuditLogsActionTypeEnum} [actionType] Filter by action type
         * @param {string} [startDate] Filter by start date and time
         * @param {string} [endDate] Filter by end date and time
         * @param {string} [targetEntityId] Filter by target entity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogs: async (pageable: Pageable, adminUserId?: number, actionType?: GetAuditLogsActionTypeEnum, startDate?: string, endDate?: string, targetEntityId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getAuditLogs', 'pageable', pageable)
            const localVarPath = `/admin/logs/audit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (adminUserId !== undefined) {
                localVarQueryParameter['adminUserId'] = adminUserId;
            }

            if (actionType !== undefined) {
                localVarQueryParameter['actionType'] = actionType;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (targetEntityId !== undefined) {
                localVarQueryParameter['targetEntityId'] = targetEntityId;
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminLoggingApi - functional programming interface
 */
export const AdminLoggingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminLoggingApiAxiosParamCreator(configuration)
    return {
        /**
         * Downloads the application log file. Only accessible by admins.
         * @summary Download application log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadApplicationLog(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadApplicationLog(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLoggingApi.downloadApplicationLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of audit logs with optional filters.
         * @summary Get audit logs
         * @param {Pageable} pageable 
         * @param {number} [adminUserId] Filter by admin user ID
         * @param {GetAuditLogsActionTypeEnum} [actionType] Filter by action type
         * @param {string} [startDate] Filter by start date and time
         * @param {string} [endDate] Filter by end date and time
         * @param {string} [targetEntityId] Filter by target entity ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuditLogs(pageable: Pageable, adminUserId?: number, actionType?: GetAuditLogsActionTypeEnum, startDate?: string, endDate?: string, targetEntityId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageAuditLogDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuditLogs(pageable, adminUserId, actionType, startDate, endDate, targetEntityId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminLoggingApi.getAuditLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminLoggingApi - factory interface
 */
export const AdminLoggingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminLoggingApiFp(configuration)
    return {
        /**
         * Downloads the application log file. Only accessible by admins.
         * @summary Download application log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadApplicationLog(options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadApplicationLog(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of audit logs with optional filters.
         * @summary Get audit logs
         * @param {AdminLoggingApiGetAuditLogsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuditLogs(requestParameters: AdminLoggingApiGetAuditLogsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PageAuditLogDto> {
            return localVarFp.getAuditLogs(requestParameters.pageable, requestParameters.adminUserId, requestParameters.actionType, requestParameters.startDate, requestParameters.endDate, requestParameters.targetEntityId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminLoggingApi - interface
 */
export interface AdminLoggingApiInterface {
    /**
     * Downloads the application log file. Only accessible by admins.
     * @summary Download application log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadApplicationLog(options?: RawAxiosRequestConfig): AxiosPromise<File>;

    /**
     * Retrieves a paginated list of audit logs with optional filters.
     * @summary Get audit logs
     * @param {AdminLoggingApiGetAuditLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuditLogs(requestParameters: AdminLoggingApiGetAuditLogsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PageAuditLogDto>;

}

/**
 * Request parameters for getAuditLogs operation in AdminLoggingApi.
 */
export interface AdminLoggingApiGetAuditLogsRequest {
    readonly pageable: Pageable

    /**
     * Filter by admin user ID
     */
    readonly adminUserId?: number

    /**
     * Filter by action type
     */
    readonly actionType?: GetAuditLogsActionTypeEnum

    /**
     * Filter by start date and time
     */
    readonly startDate?: string

    /**
     * Filter by end date and time
     */
    readonly endDate?: string

    /**
     * Filter by target entity ID
     */
    readonly targetEntityId?: string
}

/**
 * AdminLoggingApi - object-oriented interface
 */
export class AdminLoggingApi extends BaseAPI implements AdminLoggingApiInterface {
    /**
     * Downloads the application log file. Only accessible by admins.
     * @summary Download application log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadApplicationLog(options?: RawAxiosRequestConfig) {
        return AdminLoggingApiFp(this.configuration).downloadApplicationLog(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of audit logs with optional filters.
     * @summary Get audit logs
     * @param {AdminLoggingApiGetAuditLogsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAuditLogs(requestParameters: AdminLoggingApiGetAuditLogsRequest, options?: RawAxiosRequestConfig) {
        return AdminLoggingApiFp(this.configuration).getAuditLogs(requestParameters.pageable, requestParameters.adminUserId, requestParameters.actionType, requestParameters.startDate, requestParameters.endDate, requestParameters.targetEntityId, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetAuditLogsActionTypeEnum = {
    UserStatusUpdate: 'USER_STATUS_UPDATE',
    UserRoleUpdate: 'USER_ROLE_UPDATE',
    QuidCreate: 'QUID_CREATE',
    QuidStatusUpdate: 'QUID_STATUS_UPDATE',
    TransactionRefund: 'TRANSACTION_REFUND',
    WithdrawalApprove: 'WITHDRAWAL_APPROVE',
    WithdrawalReject: 'WITHDRAWAL_REJECT',
    InviteCreate: 'INVITE_CREATE',
    InviteResend: 'INVITE_RESEND',
    InviteDelete: 'INVITE_DELETE'
} as const;
export type GetAuditLogsActionTypeEnum = typeof GetAuditLogsActionTypeEnum[keyof typeof GetAuditLogsActionTypeEnum];


/**
 * AdminQuidManagementApi - axios parameter creator
 */
export const AdminQuidManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new Quid. Only accessible by admins.
         * @summary Create a new Quid
         * @param {CreateQuidRequest} createQuidRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuid: async (createQuidRequest: CreateQuidRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createQuidRequest' is not null or undefined
            assertParamExists('createQuid', 'createQuidRequest', createQuidRequest)
            const localVarPath = `/admin/quids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createQuidRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of claim attempts for a specific Quid.
         * @summary Get claim attempts for a Quid
         * @param {string} quidCode The code of the Quid.
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaimAttemptsForQuid: async (quidCode: string, pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quidCode' is not null or undefined
            assertParamExists('getClaimAttemptsForQuid', 'quidCode', quidCode)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getClaimAttemptsForQuid', 'pageable', pageable)
            const localVarPath = `/admin/quids/{quidCode}/claims`
                .replace(`{${"quidCode"}}`, encodeURIComponent(String(quidCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves Quid details using its code.
         * @summary Find Quid by code
         * @param {string} quidCode The code of the Quid to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuid1: async (quidCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quidCode' is not null or undefined
            assertParamExists('getQuid1', 'quidCode', quidCode)
            const localVarPath = `/admin/quids/{quidCode}`
                .replace(`{${"quidCode"}}`, encodeURIComponent(String(quidCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of all Quids, with optional filters.
         * @summary Get all Quids
         * @param {Pageable} pageable 
         * @param {string} [quid] Filter by Quid code
         * @param {GetQuidsStatusEnum} [status] Filter by Quid status
         * @param {string} [currency] Filter by currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuids: async (pageable: Pageable, quid?: string, status?: GetQuidsStatusEnum, currency?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getQuids', 'pageable', pageable)
            const localVarPath = `/admin/quids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (quid !== undefined) {
                localVarQueryParameter['quid'] = quid;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of winners for a specific Quid.
         * @summary Get winners for a Quid
         * @param {string} quidCode The code of the Quid.
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWinnersForQuid: async (quidCode: string, pageable: Pageable, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quidCode' is not null or undefined
            assertParamExists('getWinnersForQuid', 'quidCode', quidCode)
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getWinnersForQuid', 'pageable', pageable)
            const localVarPath = `/admin/quids/{quidCode}/winners`
                .replace(`{${"quidCode"}}`, encodeURIComponent(String(quidCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the status of an existing Quid.
         * @summary Update Quid status
         * @param {string} quidCode The code of the Quid to update.
         * @param {QuidStatusUpdateRequest} quidStatusUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuidStatus1: async (quidCode: string, quidStatusUpdateRequest: QuidStatusUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quidCode' is not null or undefined
            assertParamExists('updateQuidStatus1', 'quidCode', quidCode)
            // verify required parameter 'quidStatusUpdateRequest' is not null or undefined
            assertParamExists('updateQuidStatus1', 'quidStatusUpdateRequest', quidStatusUpdateRequest)
            const localVarPath = `/admin/quids/{quidCode}/status`
                .replace(`{${"quidCode"}}`, encodeURIComponent(String(quidCode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(quidStatusUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminQuidManagementApi - functional programming interface
 */
export const AdminQuidManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminQuidManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new Quid. Only accessible by admins.
         * @summary Create a new Quid
         * @param {CreateQuidRequest} createQuidRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createQuid(createQuidRequest: CreateQuidRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuidDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createQuid(createQuidRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminQuidManagementApi.createQuid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of claim attempts for a specific Quid.
         * @summary Get claim attempts for a Quid
         * @param {string} quidCode The code of the Quid.
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClaimAttemptsForQuid(quidCode: string, pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageClaimAttemptDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClaimAttemptsForQuid(quidCode, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminQuidManagementApi.getClaimAttemptsForQuid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves Quid details using its code.
         * @summary Find Quid by code
         * @param {string} quidCode The code of the Quid to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuid1(quidCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuidDetailDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuid1(quidCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminQuidManagementApi.getQuid1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of all Quids, with optional filters.
         * @summary Get all Quids
         * @param {Pageable} pageable 
         * @param {string} [quid] Filter by Quid code
         * @param {GetQuidsStatusEnum} [status] Filter by Quid status
         * @param {string} [currency] Filter by currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuids(pageable: Pageable, quid?: string, status?: GetQuidsStatusEnum, currency?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageQuidDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuids(pageable, quid, status, currency, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminQuidManagementApi.getQuids']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of winners for a specific Quid.
         * @summary Get winners for a Quid
         * @param {string} quidCode The code of the Quid.
         * @param {Pageable} pageable 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWinnersForQuid(quidCode: string, pageable: Pageable, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageWinnerDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWinnersForQuid(quidCode, pageable, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminQuidManagementApi.getWinnersForQuid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the status of an existing Quid.
         * @summary Update Quid status
         * @param {string} quidCode The code of the Quid to update.
         * @param {QuidStatusUpdateRequest} quidStatusUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateQuidStatus1(quidCode: string, quidStatusUpdateRequest: QuidStatusUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuidDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateQuidStatus1(quidCode, quidStatusUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminQuidManagementApi.updateQuidStatus1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminQuidManagementApi - factory interface
 */
export const AdminQuidManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminQuidManagementApiFp(configuration)
    return {
        /**
         * Creates a new Quid. Only accessible by admins.
         * @summary Create a new Quid
         * @param {AdminQuidManagementApiCreateQuidRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuid(requestParameters: AdminQuidManagementApiCreateQuidRequest, options?: RawAxiosRequestConfig): AxiosPromise<QuidDto> {
            return localVarFp.createQuid(requestParameters.createQuidRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of claim attempts for a specific Quid.
         * @summary Get claim attempts for a Quid
         * @param {AdminQuidManagementApiGetClaimAttemptsForQuidRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClaimAttemptsForQuid(requestParameters: AdminQuidManagementApiGetClaimAttemptsForQuidRequest, options?: RawAxiosRequestConfig): AxiosPromise<PageClaimAttemptDto> {
            return localVarFp.getClaimAttemptsForQuid(requestParameters.quidCode, requestParameters.pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves Quid details using its code.
         * @summary Find Quid by code
         * @param {AdminQuidManagementApiGetQuid1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuid1(requestParameters: AdminQuidManagementApiGetQuid1Request, options?: RawAxiosRequestConfig): AxiosPromise<QuidDetailDto> {
            return localVarFp.getQuid1(requestParameters.quidCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of all Quids, with optional filters.
         * @summary Get all Quids
         * @param {AdminQuidManagementApiGetQuidsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuids(requestParameters: AdminQuidManagementApiGetQuidsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PageQuidDto> {
            return localVarFp.getQuids(requestParameters.pageable, requestParameters.quid, requestParameters.status, requestParameters.currency, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of winners for a specific Quid.
         * @summary Get winners for a Quid
         * @param {AdminQuidManagementApiGetWinnersForQuidRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWinnersForQuid(requestParameters: AdminQuidManagementApiGetWinnersForQuidRequest, options?: RawAxiosRequestConfig): AxiosPromise<PageWinnerDto> {
            return localVarFp.getWinnersForQuid(requestParameters.quidCode, requestParameters.pageable, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the status of an existing Quid.
         * @summary Update Quid status
         * @param {AdminQuidManagementApiUpdateQuidStatus1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuidStatus1(requestParameters: AdminQuidManagementApiUpdateQuidStatus1Request, options?: RawAxiosRequestConfig): AxiosPromise<QuidDto> {
            return localVarFp.updateQuidStatus1(requestParameters.quidCode, requestParameters.quidStatusUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminQuidManagementApi - interface
 */
export interface AdminQuidManagementApiInterface {
    /**
     * Creates a new Quid. Only accessible by admins.
     * @summary Create a new Quid
     * @param {AdminQuidManagementApiCreateQuidRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createQuid(requestParameters: AdminQuidManagementApiCreateQuidRequest, options?: RawAxiosRequestConfig): AxiosPromise<QuidDto>;

    /**
     * Retrieves a paginated list of claim attempts for a specific Quid.
     * @summary Get claim attempts for a Quid
     * @param {AdminQuidManagementApiGetClaimAttemptsForQuidRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClaimAttemptsForQuid(requestParameters: AdminQuidManagementApiGetClaimAttemptsForQuidRequest, options?: RawAxiosRequestConfig): AxiosPromise<PageClaimAttemptDto>;

    /**
     * Retrieves Quid details using its code.
     * @summary Find Quid by code
     * @param {AdminQuidManagementApiGetQuid1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQuid1(requestParameters: AdminQuidManagementApiGetQuid1Request, options?: RawAxiosRequestConfig): AxiosPromise<QuidDetailDto>;

    /**
     * Retrieves a paginated list of all Quids, with optional filters.
     * @summary Get all Quids
     * @param {AdminQuidManagementApiGetQuidsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQuids(requestParameters: AdminQuidManagementApiGetQuidsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PageQuidDto>;

    /**
     * Retrieves a paginated list of winners for a specific Quid.
     * @summary Get winners for a Quid
     * @param {AdminQuidManagementApiGetWinnersForQuidRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWinnersForQuid(requestParameters: AdminQuidManagementApiGetWinnersForQuidRequest, options?: RawAxiosRequestConfig): AxiosPromise<PageWinnerDto>;

    /**
     * Updates the status of an existing Quid.
     * @summary Update Quid status
     * @param {AdminQuidManagementApiUpdateQuidStatus1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQuidStatus1(requestParameters: AdminQuidManagementApiUpdateQuidStatus1Request, options?: RawAxiosRequestConfig): AxiosPromise<QuidDto>;

}

/**
 * Request parameters for createQuid operation in AdminQuidManagementApi.
 */
export interface AdminQuidManagementApiCreateQuidRequest {
    readonly createQuidRequest: CreateQuidRequest
}

/**
 * Request parameters for getClaimAttemptsForQuid operation in AdminQuidManagementApi.
 */
export interface AdminQuidManagementApiGetClaimAttemptsForQuidRequest {
    /**
     * The code of the Quid.
     */
    readonly quidCode: string

    readonly pageable: Pageable
}

/**
 * Request parameters for getQuid1 operation in AdminQuidManagementApi.
 */
export interface AdminQuidManagementApiGetQuid1Request {
    /**
     * The code of the Quid to retrieve.
     */
    readonly quidCode: string
}

/**
 * Request parameters for getQuids operation in AdminQuidManagementApi.
 */
export interface AdminQuidManagementApiGetQuidsRequest {
    readonly pageable: Pageable

    /**
     * Filter by Quid code
     */
    readonly quid?: string

    /**
     * Filter by Quid status
     */
    readonly status?: GetQuidsStatusEnum

    /**
     * Filter by currency
     */
    readonly currency?: string
}

/**
 * Request parameters for getWinnersForQuid operation in AdminQuidManagementApi.
 */
export interface AdminQuidManagementApiGetWinnersForQuidRequest {
    /**
     * The code of the Quid.
     */
    readonly quidCode: string

    readonly pageable: Pageable
}

/**
 * Request parameters for updateQuidStatus1 operation in AdminQuidManagementApi.
 */
export interface AdminQuidManagementApiUpdateQuidStatus1Request {
    /**
     * The code of the Quid to update.
     */
    readonly quidCode: string

    readonly quidStatusUpdateRequest: QuidStatusUpdateRequest
}

/**
 * AdminQuidManagementApi - object-oriented interface
 */
export class AdminQuidManagementApi extends BaseAPI implements AdminQuidManagementApiInterface {
    /**
     * Creates a new Quid. Only accessible by admins.
     * @summary Create a new Quid
     * @param {AdminQuidManagementApiCreateQuidRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createQuid(requestParameters: AdminQuidManagementApiCreateQuidRequest, options?: RawAxiosRequestConfig) {
        return AdminQuidManagementApiFp(this.configuration).createQuid(requestParameters.createQuidRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of claim attempts for a specific Quid.
     * @summary Get claim attempts for a Quid
     * @param {AdminQuidManagementApiGetClaimAttemptsForQuidRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getClaimAttemptsForQuid(requestParameters: AdminQuidManagementApiGetClaimAttemptsForQuidRequest, options?: RawAxiosRequestConfig) {
        return AdminQuidManagementApiFp(this.configuration).getClaimAttemptsForQuid(requestParameters.quidCode, requestParameters.pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves Quid details using its code.
     * @summary Find Quid by code
     * @param {AdminQuidManagementApiGetQuid1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getQuid1(requestParameters: AdminQuidManagementApiGetQuid1Request, options?: RawAxiosRequestConfig) {
        return AdminQuidManagementApiFp(this.configuration).getQuid1(requestParameters.quidCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of all Quids, with optional filters.
     * @summary Get all Quids
     * @param {AdminQuidManagementApiGetQuidsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getQuids(requestParameters: AdminQuidManagementApiGetQuidsRequest, options?: RawAxiosRequestConfig) {
        return AdminQuidManagementApiFp(this.configuration).getQuids(requestParameters.pageable, requestParameters.quid, requestParameters.status, requestParameters.currency, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of winners for a specific Quid.
     * @summary Get winners for a Quid
     * @param {AdminQuidManagementApiGetWinnersForQuidRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWinnersForQuid(requestParameters: AdminQuidManagementApiGetWinnersForQuidRequest, options?: RawAxiosRequestConfig) {
        return AdminQuidManagementApiFp(this.configuration).getWinnersForQuid(requestParameters.quidCode, requestParameters.pageable, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the status of an existing Quid.
     * @summary Update Quid status
     * @param {AdminQuidManagementApiUpdateQuidStatus1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateQuidStatus1(requestParameters: AdminQuidManagementApiUpdateQuidStatus1Request, options?: RawAxiosRequestConfig) {
        return AdminQuidManagementApiFp(this.configuration).updateQuidStatus1(requestParameters.quidCode, requestParameters.quidStatusUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetQuidsStatusEnum = {
    Active: 'ACTIVE',
    Split: 'SPLIT',
    Claimed: 'CLAIMED',
    Blocked: 'BLOCKED',
    Expired: 'EXPIRED',
    Conflicted: 'CONFLICTED'
} as const;
export type GetQuidsStatusEnum = typeof GetQuidsStatusEnum[keyof typeof GetQuidsStatusEnum];


/**
 * AdminTransactionManagementApi - axios parameter creator
 */
export const AdminTransactionManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves transaction details using its ID.
         * @summary Find transaction by ID
         * @param {string} transactionId The ID of the transaction to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction: async (transactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getTransaction', 'transactionId', transactionId)
            const localVarPath = `/admin/transactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of all transactions, with optional filters.
         * @summary Get all transactions
         * @param {Pageable} pageable 
         * @param {GetTransactionsStatusEnum} [status] Filter by transaction status
         * @param {string} [paymentProvider] Filter by payment provider
         * @param {string} [currency] Filter by currency code
         * @param {string} [search] Search term to filter transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions: async (pageable: Pageable, status?: GetTransactionsStatusEnum, paymentProvider?: string, currency?: string, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getTransactions', 'pageable', pageable)
            const localVarPath = `/admin/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (paymentProvider !== undefined) {
                localVarQueryParameter['paymentProvider'] = paymentProvider;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refunds a transaction by its ID. Only accessible by admins.
         * @summary Refund a transaction
         * @param {string} transactionId The ID of the transaction to refund.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundTransaction: async (transactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('refundTransaction', 'transactionId', transactionId)
            const localVarPath = `/admin/transactions/{transactionId}/refund`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminTransactionManagementApi - functional programming interface
 */
export const AdminTransactionManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminTransactionManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves transaction details using its ID.
         * @summary Find transaction by ID
         * @param {string} transactionId The ID of the transaction to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransaction(transactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDetailDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransaction(transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminTransactionManagementApi.getTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of all transactions, with optional filters.
         * @summary Get all transactions
         * @param {Pageable} pageable 
         * @param {GetTransactionsStatusEnum} [status] Filter by transaction status
         * @param {string} [paymentProvider] Filter by payment provider
         * @param {string} [currency] Filter by currency code
         * @param {string} [search] Search term to filter transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactions(pageable: Pageable, status?: GetTransactionsStatusEnum, paymentProvider?: string, currency?: string, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageTransactionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactions(pageable, status, paymentProvider, currency, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminTransactionManagementApi.getTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Refunds a transaction by its ID. Only accessible by admins.
         * @summary Refund a transaction
         * @param {string} transactionId The ID of the transaction to refund.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refundTransaction(transactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDetailDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refundTransaction(transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminTransactionManagementApi.refundTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminTransactionManagementApi - factory interface
 */
export const AdminTransactionManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminTransactionManagementApiFp(configuration)
    return {
        /**
         * Retrieves transaction details using its ID.
         * @summary Find transaction by ID
         * @param {AdminTransactionManagementApiGetTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransaction(requestParameters: AdminTransactionManagementApiGetTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionDetailDto> {
            return localVarFp.getTransaction(requestParameters.transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of all transactions, with optional filters.
         * @summary Get all transactions
         * @param {AdminTransactionManagementApiGetTransactionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(requestParameters: AdminTransactionManagementApiGetTransactionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PageTransactionDto> {
            return localVarFp.getTransactions(requestParameters.pageable, requestParameters.status, requestParameters.paymentProvider, requestParameters.currency, requestParameters.search, options).then((request) => request(axios, basePath));
        },
        /**
         * Refunds a transaction by its ID. Only accessible by admins.
         * @summary Refund a transaction
         * @param {AdminTransactionManagementApiRefundTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundTransaction(requestParameters: AdminTransactionManagementApiRefundTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionDetailDto> {
            return localVarFp.refundTransaction(requestParameters.transactionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminTransactionManagementApi - interface
 */
export interface AdminTransactionManagementApiInterface {
    /**
     * Retrieves transaction details using its ID.
     * @summary Find transaction by ID
     * @param {AdminTransactionManagementApiGetTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransaction(requestParameters: AdminTransactionManagementApiGetTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionDetailDto>;

    /**
     * Retrieves a paginated list of all transactions, with optional filters.
     * @summary Get all transactions
     * @param {AdminTransactionManagementApiGetTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTransactions(requestParameters: AdminTransactionManagementApiGetTransactionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PageTransactionDto>;

    /**
     * Refunds a transaction by its ID. Only accessible by admins.
     * @summary Refund a transaction
     * @param {AdminTransactionManagementApiRefundTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refundTransaction(requestParameters: AdminTransactionManagementApiRefundTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionDetailDto>;

}

/**
 * Request parameters for getTransaction operation in AdminTransactionManagementApi.
 */
export interface AdminTransactionManagementApiGetTransactionRequest {
    /**
     * The ID of the transaction to retrieve.
     */
    readonly transactionId: string
}

/**
 * Request parameters for getTransactions operation in AdminTransactionManagementApi.
 */
export interface AdminTransactionManagementApiGetTransactionsRequest {
    readonly pageable: Pageable

    /**
     * Filter by transaction status
     */
    readonly status?: GetTransactionsStatusEnum

    /**
     * Filter by payment provider
     */
    readonly paymentProvider?: string

    /**
     * Filter by currency code
     */
    readonly currency?: string

    /**
     * Search term to filter transactions
     */
    readonly search?: string
}

/**
 * Request parameters for refundTransaction operation in AdminTransactionManagementApi.
 */
export interface AdminTransactionManagementApiRefundTransactionRequest {
    /**
     * The ID of the transaction to refund.
     */
    readonly transactionId: string
}

/**
 * AdminTransactionManagementApi - object-oriented interface
 */
export class AdminTransactionManagementApi extends BaseAPI implements AdminTransactionManagementApiInterface {
    /**
     * Retrieves transaction details using its ID.
     * @summary Find transaction by ID
     * @param {AdminTransactionManagementApiGetTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTransaction(requestParameters: AdminTransactionManagementApiGetTransactionRequest, options?: RawAxiosRequestConfig) {
        return AdminTransactionManagementApiFp(this.configuration).getTransaction(requestParameters.transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of all transactions, with optional filters.
     * @summary Get all transactions
     * @param {AdminTransactionManagementApiGetTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getTransactions(requestParameters: AdminTransactionManagementApiGetTransactionsRequest, options?: RawAxiosRequestConfig) {
        return AdminTransactionManagementApiFp(this.configuration).getTransactions(requestParameters.pageable, requestParameters.status, requestParameters.paymentProvider, requestParameters.currency, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refunds a transaction by its ID. Only accessible by admins.
     * @summary Refund a transaction
     * @param {AdminTransactionManagementApiRefundTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public refundTransaction(requestParameters: AdminTransactionManagementApiRefundTransactionRequest, options?: RawAxiosRequestConfig) {
        return AdminTransactionManagementApiFp(this.configuration).refundTransaction(requestParameters.transactionId, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetTransactionsStatusEnum = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Success: 'SUCCESS',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Refunded: 'REFUNDED',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    UnknownStatus: 'UNKNOWN_STATUS'
} as const;
export type GetTransactionsStatusEnum = typeof GetTransactionsStatusEnum[keyof typeof GetTransactionsStatusEnum];


/**
 * AdminUsersApi - axios parameter creator
 */
export const AdminUsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve detailed information about a specific user. Note: Will be expanded with transaction history and audit logs.
         * @summary Get user details by ID
         * @param {number} userId Unique user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDetails: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserDetails', 'userId', userId)
            const localVarPath = `/admin/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a paginated list of users with optional filters by email, status, or role.
         * @summary List and filter users
         * @param {Pageable} pageable Pagination and sorting (e.g., ?page&#x3D;0&amp;size&#x3D;20&amp;sort&#x3D;email,desc)
         * @param {string} [email] Filter by user email (partial match)
         * @param {string} [status] Filter by account status: \&#39;enabled\&#39; or \&#39;disabled\&#39;
         * @param {ListUsersRoleEnum} [role] Filter by user role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (pageable: Pageable, email?: string, status?: string, role?: ListUsersRoleEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('listUsers', 'pageable', pageable)
            const localVarPath = `/admin/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign a new role to a user. Only accessible to ADMIN.
         * @summary Update user role
         * @param {number} userId User ID to update
         * @param {UserRoleUpdateDto} userRoleUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRole: async (userId: number, userRoleUpdateDto: UserRoleUpdateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserRole', 'userId', userId)
            // verify required parameter 'userRoleUpdateDto' is not null or undefined
            assertParamExists('updateUserRole', 'userRoleUpdateDto', userRoleUpdateDto)
            const localVarPath = `/admin/users/{userId}/role`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRoleUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable, disable, or lock a user account.
         * @summary Update user account status
         * @param {number} userId User ID to update
         * @param {UserStatusUpdateDto} userStatusUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserStatus: async (userId: number, userStatusUpdateDto: UserStatusUpdateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateUserStatus', 'userId', userId)
            // verify required parameter 'userStatusUpdateDto' is not null or undefined
            assertParamExists('updateUserStatus', 'userStatusUpdateDto', userStatusUpdateDto)
            const localVarPath = `/admin/users/{userId}/status`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userStatusUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminUsersApi - functional programming interface
 */
export const AdminUsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminUsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve detailed information about a specific user. Note: Will be expanded with transaction history and audit logs.
         * @summary Get user details by ID
         * @param {number} userId Unique user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserDetails(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDetails(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.getUserDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a paginated list of users with optional filters by email, status, or role.
         * @summary List and filter users
         * @param {Pageable} pageable Pagination and sorting (e.g., ?page&#x3D;0&amp;size&#x3D;20&amp;sort&#x3D;email,desc)
         * @param {string} [email] Filter by user email (partial match)
         * @param {string} [status] Filter by account status: \&#39;enabled\&#39; or \&#39;disabled\&#39;
         * @param {ListUsersRoleEnum} [role] Filter by user role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(pageable: Pageable, email?: string, status?: string, role?: ListUsersRoleEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Page>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(pageable, email, status, role, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.listUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign a new role to a user. Only accessible to ADMIN.
         * @summary Update user role
         * @param {number} userId User ID to update
         * @param {UserRoleUpdateDto} userRoleUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserRole(userId: number, userRoleUpdateDto: UserRoleUpdateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserRole(userId, userRoleUpdateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.updateUserRole']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enable, disable, or lock a user account.
         * @summary Update user account status
         * @param {number} userId User ID to update
         * @param {UserStatusUpdateDto} userStatusUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserStatus(userId: number, userStatusUpdateDto: UserStatusUpdateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserStatus(userId, userStatusUpdateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminUsersApi.updateUserStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminUsersApi - factory interface
 */
export const AdminUsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminUsersApiFp(configuration)
    return {
        /**
         * Retrieve detailed information about a specific user. Note: Will be expanded with transaction history and audit logs.
         * @summary Get user details by ID
         * @param {AdminUsersApiGetUserDetailsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDetails(requestParameters: AdminUsersApiGetUserDetailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.getUserDetails(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a paginated list of users with optional filters by email, status, or role.
         * @summary List and filter users
         * @param {AdminUsersApiListUsersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(requestParameters: AdminUsersApiListUsersRequest, options?: RawAxiosRequestConfig): AxiosPromise<Page> {
            return localVarFp.listUsers(requestParameters.pageable, requestParameters.email, requestParameters.status, requestParameters.role, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign a new role to a user. Only accessible to ADMIN.
         * @summary Update user role
         * @param {AdminUsersApiUpdateUserRoleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRole(requestParameters: AdminUsersApiUpdateUserRoleRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.updateUserRole(requestParameters.userId, requestParameters.userRoleUpdateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable, disable, or lock a user account.
         * @summary Update user account status
         * @param {AdminUsersApiUpdateUserStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserStatus(requestParameters: AdminUsersApiUpdateUserStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserDto> {
            return localVarFp.updateUserStatus(requestParameters.userId, requestParameters.userStatusUpdateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminUsersApi - interface
 */
export interface AdminUsersApiInterface {
    /**
     * Retrieve detailed information about a specific user. Note: Will be expanded with transaction history and audit logs.
     * @summary Get user details by ID
     * @param {AdminUsersApiGetUserDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserDetails(requestParameters: AdminUsersApiGetUserDetailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserDto>;

    /**
     * Retrieve a paginated list of users with optional filters by email, status, or role.
     * @summary List and filter users
     * @param {AdminUsersApiListUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listUsers(requestParameters: AdminUsersApiListUsersRequest, options?: RawAxiosRequestConfig): AxiosPromise<Page>;

    /**
     * Assign a new role to a user. Only accessible to ADMIN.
     * @summary Update user role
     * @param {AdminUsersApiUpdateUserRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserRole(requestParameters: AdminUsersApiUpdateUserRoleRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserDto>;

    /**
     * Enable, disable, or lock a user account.
     * @summary Update user account status
     * @param {AdminUsersApiUpdateUserStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUserStatus(requestParameters: AdminUsersApiUpdateUserStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserDto>;

}

/**
 * Request parameters for getUserDetails operation in AdminUsersApi.
 */
export interface AdminUsersApiGetUserDetailsRequest {
    /**
     * Unique user ID
     */
    readonly userId: number
}

/**
 * Request parameters for listUsers operation in AdminUsersApi.
 */
export interface AdminUsersApiListUsersRequest {
    /**
     * Pagination and sorting (e.g., ?page&#x3D;0&amp;size&#x3D;20&amp;sort&#x3D;email,desc)
     */
    readonly pageable: Pageable

    /**
     * Filter by user email (partial match)
     */
    readonly email?: string

    /**
     * Filter by account status: \&#39;enabled\&#39; or \&#39;disabled\&#39;
     */
    readonly status?: string

    /**
     * Filter by user role
     */
    readonly role?: ListUsersRoleEnum
}

/**
 * Request parameters for updateUserRole operation in AdminUsersApi.
 */
export interface AdminUsersApiUpdateUserRoleRequest {
    /**
     * User ID to update
     */
    readonly userId: number

    readonly userRoleUpdateDto: UserRoleUpdateDto
}

/**
 * Request parameters for updateUserStatus operation in AdminUsersApi.
 */
export interface AdminUsersApiUpdateUserStatusRequest {
    /**
     * User ID to update
     */
    readonly userId: number

    readonly userStatusUpdateDto: UserStatusUpdateDto
}

/**
 * AdminUsersApi - object-oriented interface
 */
export class AdminUsersApi extends BaseAPI implements AdminUsersApiInterface {
    /**
     * Retrieve detailed information about a specific user. Note: Will be expanded with transaction history and audit logs.
     * @summary Get user details by ID
     * @param {AdminUsersApiGetUserDetailsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserDetails(requestParameters: AdminUsersApiGetUserDetailsRequest, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).getUserDetails(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a paginated list of users with optional filters by email, status, or role.
     * @summary List and filter users
     * @param {AdminUsersApiListUsersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listUsers(requestParameters: AdminUsersApiListUsersRequest, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).listUsers(requestParameters.pageable, requestParameters.email, requestParameters.status, requestParameters.role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign a new role to a user. Only accessible to ADMIN.
     * @summary Update user role
     * @param {AdminUsersApiUpdateUserRoleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateUserRole(requestParameters: AdminUsersApiUpdateUserRoleRequest, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).updateUserRole(requestParameters.userId, requestParameters.userRoleUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable, disable, or lock a user account.
     * @summary Update user account status
     * @param {AdminUsersApiUpdateUserStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateUserStatus(requestParameters: AdminUsersApiUpdateUserStatusRequest, options?: RawAxiosRequestConfig) {
        return AdminUsersApiFp(this.configuration).updateUserStatus(requestParameters.userId, requestParameters.userStatusUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }
}

export const ListUsersRoleEnum = {
    User: 'USER',
    Admin: 'ADMIN',
    Moderator: 'MODERATOR'
} as const;
export type ListUsersRoleEnum = typeof ListUsersRoleEnum[keyof typeof ListUsersRoleEnum];


/**
 * AdminWithdrawalManagementApi - axios parameter creator
 */
export const AdminWithdrawalManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Approves a withdrawal request by its ID. Only accessible by admins.
         * @summary Approve a withdrawal request
         * @param {number} withdrawalId The ID of the withdrawal request to approve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawal: async (withdrawalId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalId' is not null or undefined
            assertParamExists('approveWithdrawal', 'withdrawalId', withdrawalId)
            const localVarPath = `/admin/withdrawals/{withdrawalId}/approve`
                .replace(`{${"withdrawalId"}}`, encodeURIComponent(String(withdrawalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves withdrawal request details using its ID.
         * @summary Get withdrawal by ID
         * @param {number} withdrawalId The ID of the withdrawal request to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawal: async (withdrawalId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalId' is not null or undefined
            assertParamExists('getWithdrawal', 'withdrawalId', withdrawalId)
            const localVarPath = `/admin/withdrawals/{withdrawalId}`
                .replace(`{${"withdrawalId"}}`, encodeURIComponent(String(withdrawalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a paginated list of all withdrawal requests, with optional filters.
         * @summary Get all withdrawal requests
         * @param {Pageable} pageable 
         * @param {GetWithdrawalsStatusEnum} [status] Filter by withdrawal status
         * @param {GetWithdrawalsCurrencyEnum} [currency] Filter by currency
         * @param {string} [search] Search term to filter withdrawals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawals: async (pageable: Pageable, status?: GetWithdrawalsStatusEnum, currency?: GetWithdrawalsCurrencyEnum, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pageable' is not null or undefined
            assertParamExists('getWithdrawals', 'pageable', pageable)
            const localVarPath = `/admin/withdrawals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (currency !== undefined) {
                localVarQueryParameter['currency'] = currency;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (pageable !== undefined) {
                for (const [key, value] of Object.entries(pageable)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rejects a withdrawal request by its ID. Only accessible by admins.
         * @summary Reject a withdrawal request
         * @param {number} withdrawalId The ID of the withdrawal request to reject.
         * @param {RejectWithdrawalRequestDto} rejectWithdrawalRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawal: async (withdrawalId: number, rejectWithdrawalRequestDto: RejectWithdrawalRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalId' is not null or undefined
            assertParamExists('rejectWithdrawal', 'withdrawalId', withdrawalId)
            // verify required parameter 'rejectWithdrawalRequestDto' is not null or undefined
            assertParamExists('rejectWithdrawal', 'rejectWithdrawalRequestDto', rejectWithdrawalRequestDto)
            const localVarPath = `/admin/withdrawals/{withdrawalId}/reject`
                .replace(`{${"withdrawalId"}}`, encodeURIComponent(String(withdrawalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rejectWithdrawalRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminWithdrawalManagementApi - functional programming interface
 */
export const AdminWithdrawalManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminWithdrawalManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Approves a withdrawal request by its ID. Only accessible by admins.
         * @summary Approve a withdrawal request
         * @param {number} withdrawalId The ID of the withdrawal request to approve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveWithdrawal(withdrawalId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalRequestDetailDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.approveWithdrawal(withdrawalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminWithdrawalManagementApi.approveWithdrawal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves withdrawal request details using its ID.
         * @summary Get withdrawal by ID
         * @param {number} withdrawalId The ID of the withdrawal request to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWithdrawal(withdrawalId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalRequestDetailDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWithdrawal(withdrawalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminWithdrawalManagementApi.getWithdrawal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a paginated list of all withdrawal requests, with optional filters.
         * @summary Get all withdrawal requests
         * @param {Pageable} pageable 
         * @param {GetWithdrawalsStatusEnum} [status] Filter by withdrawal status
         * @param {GetWithdrawalsCurrencyEnum} [currency] Filter by currency
         * @param {string} [search] Search term to filter withdrawals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWithdrawals(pageable: Pageable, status?: GetWithdrawalsStatusEnum, currency?: GetWithdrawalsCurrencyEnum, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageWithdrawalRequestDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWithdrawals(pageable, status, currency, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminWithdrawalManagementApi.getWithdrawals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Rejects a withdrawal request by its ID. Only accessible by admins.
         * @summary Reject a withdrawal request
         * @param {number} withdrawalId The ID of the withdrawal request to reject.
         * @param {RejectWithdrawalRequestDto} rejectWithdrawalRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectWithdrawal(withdrawalId: number, rejectWithdrawalRequestDto: RejectWithdrawalRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalRequestDetailDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rejectWithdrawal(withdrawalId, rejectWithdrawalRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminWithdrawalManagementApi.rejectWithdrawal']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminWithdrawalManagementApi - factory interface
 */
export const AdminWithdrawalManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminWithdrawalManagementApiFp(configuration)
    return {
        /**
         * Approves a withdrawal request by its ID. Only accessible by admins.
         * @summary Approve a withdrawal request
         * @param {AdminWithdrawalManagementApiApproveWithdrawalRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveWithdrawal(requestParameters: AdminWithdrawalManagementApiApproveWithdrawalRequest, options?: RawAxiosRequestConfig): AxiosPromise<WithdrawalRequestDetailDto> {
            return localVarFp.approveWithdrawal(requestParameters.withdrawalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves withdrawal request details using its ID.
         * @summary Get withdrawal by ID
         * @param {AdminWithdrawalManagementApiGetWithdrawalRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawal(requestParameters: AdminWithdrawalManagementApiGetWithdrawalRequest, options?: RawAxiosRequestConfig): AxiosPromise<WithdrawalRequestDetailDto> {
            return localVarFp.getWithdrawal(requestParameters.withdrawalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a paginated list of all withdrawal requests, with optional filters.
         * @summary Get all withdrawal requests
         * @param {AdminWithdrawalManagementApiGetWithdrawalsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawals(requestParameters: AdminWithdrawalManagementApiGetWithdrawalsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PageWithdrawalRequestDto> {
            return localVarFp.getWithdrawals(requestParameters.pageable, requestParameters.status, requestParameters.currency, requestParameters.search, options).then((request) => request(axios, basePath));
        },
        /**
         * Rejects a withdrawal request by its ID. Only accessible by admins.
         * @summary Reject a withdrawal request
         * @param {AdminWithdrawalManagementApiRejectWithdrawalRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectWithdrawal(requestParameters: AdminWithdrawalManagementApiRejectWithdrawalRequest, options?: RawAxiosRequestConfig): AxiosPromise<WithdrawalRequestDetailDto> {
            return localVarFp.rejectWithdrawal(requestParameters.withdrawalId, requestParameters.rejectWithdrawalRequestDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminWithdrawalManagementApi - interface
 */
export interface AdminWithdrawalManagementApiInterface {
    /**
     * Approves a withdrawal request by its ID. Only accessible by admins.
     * @summary Approve a withdrawal request
     * @param {AdminWithdrawalManagementApiApproveWithdrawalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveWithdrawal(requestParameters: AdminWithdrawalManagementApiApproveWithdrawalRequest, options?: RawAxiosRequestConfig): AxiosPromise<WithdrawalRequestDetailDto>;

    /**
     * Retrieves withdrawal request details using its ID.
     * @summary Get withdrawal by ID
     * @param {AdminWithdrawalManagementApiGetWithdrawalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWithdrawal(requestParameters: AdminWithdrawalManagementApiGetWithdrawalRequest, options?: RawAxiosRequestConfig): AxiosPromise<WithdrawalRequestDetailDto>;

    /**
     * Retrieves a paginated list of all withdrawal requests, with optional filters.
     * @summary Get all withdrawal requests
     * @param {AdminWithdrawalManagementApiGetWithdrawalsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getWithdrawals(requestParameters: AdminWithdrawalManagementApiGetWithdrawalsRequest, options?: RawAxiosRequestConfig): AxiosPromise<PageWithdrawalRequestDto>;

    /**
     * Rejects a withdrawal request by its ID. Only accessible by admins.
     * @summary Reject a withdrawal request
     * @param {AdminWithdrawalManagementApiRejectWithdrawalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rejectWithdrawal(requestParameters: AdminWithdrawalManagementApiRejectWithdrawalRequest, options?: RawAxiosRequestConfig): AxiosPromise<WithdrawalRequestDetailDto>;

}

/**
 * Request parameters for approveWithdrawal operation in AdminWithdrawalManagementApi.
 */
export interface AdminWithdrawalManagementApiApproveWithdrawalRequest {
    /**
     * The ID of the withdrawal request to approve.
     */
    readonly withdrawalId: number
}

/**
 * Request parameters for getWithdrawal operation in AdminWithdrawalManagementApi.
 */
export interface AdminWithdrawalManagementApiGetWithdrawalRequest {
    /**
     * The ID of the withdrawal request to retrieve.
     */
    readonly withdrawalId: number
}

/**
 * Request parameters for getWithdrawals operation in AdminWithdrawalManagementApi.
 */
export interface AdminWithdrawalManagementApiGetWithdrawalsRequest {
    readonly pageable: Pageable

    /**
     * Filter by withdrawal status
     */
    readonly status?: GetWithdrawalsStatusEnum

    /**
     * Filter by currency
     */
    readonly currency?: GetWithdrawalsCurrencyEnum

    /**
     * Search term to filter withdrawals
     */
    readonly search?: string
}

/**
 * Request parameters for rejectWithdrawal operation in AdminWithdrawalManagementApi.
 */
export interface AdminWithdrawalManagementApiRejectWithdrawalRequest {
    /**
     * The ID of the withdrawal request to reject.
     */
    readonly withdrawalId: number

    readonly rejectWithdrawalRequestDto: RejectWithdrawalRequestDto
}

/**
 * AdminWithdrawalManagementApi - object-oriented interface
 */
export class AdminWithdrawalManagementApi extends BaseAPI implements AdminWithdrawalManagementApiInterface {
    /**
     * Approves a withdrawal request by its ID. Only accessible by admins.
     * @summary Approve a withdrawal request
     * @param {AdminWithdrawalManagementApiApproveWithdrawalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public approveWithdrawal(requestParameters: AdminWithdrawalManagementApiApproveWithdrawalRequest, options?: RawAxiosRequestConfig) {
        return AdminWithdrawalManagementApiFp(this.configuration).approveWithdrawal(requestParameters.withdrawalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves withdrawal request details using its ID.
     * @summary Get withdrawal by ID
     * @param {AdminWithdrawalManagementApiGetWithdrawalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWithdrawal(requestParameters: AdminWithdrawalManagementApiGetWithdrawalRequest, options?: RawAxiosRequestConfig) {
        return AdminWithdrawalManagementApiFp(this.configuration).getWithdrawal(requestParameters.withdrawalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a paginated list of all withdrawal requests, with optional filters.
     * @summary Get all withdrawal requests
     * @param {AdminWithdrawalManagementApiGetWithdrawalsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getWithdrawals(requestParameters: AdminWithdrawalManagementApiGetWithdrawalsRequest, options?: RawAxiosRequestConfig) {
        return AdminWithdrawalManagementApiFp(this.configuration).getWithdrawals(requestParameters.pageable, requestParameters.status, requestParameters.currency, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rejects a withdrawal request by its ID. Only accessible by admins.
     * @summary Reject a withdrawal request
     * @param {AdminWithdrawalManagementApiRejectWithdrawalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public rejectWithdrawal(requestParameters: AdminWithdrawalManagementApiRejectWithdrawalRequest, options?: RawAxiosRequestConfig) {
        return AdminWithdrawalManagementApiFp(this.configuration).rejectWithdrawal(requestParameters.withdrawalId, requestParameters.rejectWithdrawalRequestDto, options).then((request) => request(this.axios, this.basePath));
    }
}

export const GetWithdrawalsStatusEnum = {
    Pending: 'PENDING',
    Processing: 'PROCESSING',
    Success: 'SUCCESS',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Refunded: 'REFUNDED',
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    UnknownStatus: 'UNKNOWN_STATUS'
} as const;
export type GetWithdrawalsStatusEnum = typeof GetWithdrawalsStatusEnum[keyof typeof GetWithdrawalsStatusEnum];
export const GetWithdrawalsCurrencyEnum = {
    Ghs: 'GHS',
    Ngn: 'NGN',
    Zar: 'ZAR',
    Kes: 'KES'
} as const;
export type GetWithdrawalsCurrencyEnum = typeof GetWithdrawalsCurrencyEnum[keyof typeof GetWithdrawalsCurrencyEnum];


/**
 * AuthenticationApi - axios parameter creator
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initiates the password reset process for a user\'s email address.
         * @summary Request a password reset
         * @param {ForgotPasswordRequest} forgotPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword: async (forgotPasswordRequest: ForgotPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordRequest' is not null or undefined
            assertParamExists('forgotPassword', 'forgotPasswordRequest', forgotPasswordRequest)
            const localVarPath = `/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logs in a user and returns a JWT token.
         * @summary Authenticate user
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Registers a new user using an invite token and returns a JWT token.
         * @summary Register a new user
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerRequest: RegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerRequest' is not null or undefined
            assertParamExists('register', 'registerRequest', registerRequest)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets the user\'s password using a valid reset token.
         * @summary Reset user password
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword: async (resetPasswordRequest: ResetPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordRequest' is not null or undefined
            assertParamExists('resetPassword', 'resetPasswordRequest', resetPasswordRequest)
            const localVarPath = `/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks if an invite token is valid.
         * @summary Validate an invite token
         * @param {string} token The invite token to validate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateInvite: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('validateInvite', 'token', token)
            const localVarPath = `/auth/invites/validate/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Initiates the password reset process for a user\'s email address.
         * @summary Request a password reset
         * @param {ForgotPasswordRequest} forgotPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgotPassword(forgotPasswordRequest: ForgotPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgotPassword(forgotPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.forgotPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logs in a user and returns a JWT token.
         * @summary Authenticate user
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtAuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Registers a new user using an invite token and returns a JWT token.
         * @summary Register a new user
         * @param {RegisterRequest} registerRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerRequest: RegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JwtAuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resets the user\'s password using a valid reset token.
         * @summary Reset user password
         * @param {ResetPasswordRequest} resetPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetPassword(resetPasswordRequest: ResetPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(resetPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.resetPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks if an invite token is valid.
         * @summary Validate an invite token
         * @param {string} token The invite token to validate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateInvite(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateInvite(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.validateInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Initiates the password reset process for a user\'s email address.
         * @summary Request a password reset
         * @param {AuthenticationApiForgotPasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgotPassword(requestParameters: AuthenticationApiForgotPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.forgotPassword(requestParameters.forgotPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Logs in a user and returns a JWT token.
         * @summary Authenticate user
         * @param {AuthenticationApiLoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(requestParameters: AuthenticationApiLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<JwtAuthenticationResponse> {
            return localVarFp.login(requestParameters.loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Registers a new user using an invite token and returns a JWT token.
         * @summary Register a new user
         * @param {AuthenticationApiRegisterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(requestParameters: AuthenticationApiRegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<JwtAuthenticationResponse> {
            return localVarFp.register(requestParameters.registerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets the user\'s password using a valid reset token.
         * @summary Reset user password
         * @param {AuthenticationApiResetPasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetPassword(requestParameters: AuthenticationApiResetPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resetPassword(requestParameters.resetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks if an invite token is valid.
         * @summary Validate an invite token
         * @param {AuthenticationApiValidateInviteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateInvite(requestParameters: AuthenticationApiValidateInviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.validateInvite(requestParameters.token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - interface
 */
export interface AuthenticationApiInterface {
    /**
     * Initiates the password reset process for a user\'s email address.
     * @summary Request a password reset
     * @param {AuthenticationApiForgotPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forgotPassword(requestParameters: AuthenticationApiForgotPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Logs in a user and returns a JWT token.
     * @summary Authenticate user
     * @param {AuthenticationApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    login(requestParameters: AuthenticationApiLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<JwtAuthenticationResponse>;

    /**
     * Registers a new user using an invite token and returns a JWT token.
     * @summary Register a new user
     * @param {AuthenticationApiRegisterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register(requestParameters: AuthenticationApiRegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<JwtAuthenticationResponse>;

    /**
     * Resets the user\'s password using a valid reset token.
     * @summary Reset user password
     * @param {AuthenticationApiResetPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPassword(requestParameters: AuthenticationApiResetPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Checks if an invite token is valid.
     * @summary Validate an invite token
     * @param {AuthenticationApiValidateInviteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validateInvite(requestParameters: AuthenticationApiValidateInviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * Request parameters for forgotPassword operation in AuthenticationApi.
 */
export interface AuthenticationApiForgotPasswordRequest {
    readonly forgotPasswordRequest: ForgotPasswordRequest
}

/**
 * Request parameters for login operation in AuthenticationApi.
 */
export interface AuthenticationApiLoginRequest {
    readonly loginRequest: LoginRequest
}

/**
 * Request parameters for register operation in AuthenticationApi.
 */
export interface AuthenticationApiRegisterRequest {
    readonly registerRequest: RegisterRequest
}

/**
 * Request parameters for resetPassword operation in AuthenticationApi.
 */
export interface AuthenticationApiResetPasswordRequest {
    readonly resetPasswordRequest: ResetPasswordRequest
}

/**
 * Request parameters for validateInvite operation in AuthenticationApi.
 */
export interface AuthenticationApiValidateInviteRequest {
    /**
     * The invite token to validate.
     */
    readonly token: string
}

/**
 * AuthenticationApi - object-oriented interface
 */
export class AuthenticationApi extends BaseAPI implements AuthenticationApiInterface {
    /**
     * Initiates the password reset process for a user\'s email address.
     * @summary Request a password reset
     * @param {AuthenticationApiForgotPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public forgotPassword(requestParameters: AuthenticationApiForgotPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).forgotPassword(requestParameters.forgotPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logs in a user and returns a JWT token.
     * @summary Authenticate user
     * @param {AuthenticationApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public login(requestParameters: AuthenticationApiLoginRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).login(requestParameters.loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Registers a new user using an invite token and returns a JWT token.
     * @summary Register a new user
     * @param {AuthenticationApiRegisterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public register(requestParameters: AuthenticationApiRegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).register(requestParameters.registerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets the user\'s password using a valid reset token.
     * @summary Reset user password
     * @param {AuthenticationApiResetPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resetPassword(requestParameters: AuthenticationApiResetPasswordRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).resetPassword(requestParameters.resetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks if an invite token is valid.
     * @summary Validate an invite token
     * @param {AuthenticationApiValidateInviteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public validateInvite(requestParameters: AuthenticationApiValidateInviteRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).validateInvite(requestParameters.token, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DynamicAPIKeyApi - axios parameter creator
 */
export const DynamicAPIKeyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Completes the ECDH key exchange and returns the shared secret (API key).
         * @summary Complete key exchange
         * @param {EcdhCompleteRequest} ecdhCompleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeKeyExchange: async (ecdhCompleteRequest: EcdhCompleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ecdhCompleteRequest' is not null or undefined
            assertParamExists('completeKeyExchange', 'ecdhCompleteRequest', ecdhCompleteRequest)
            const localVarPath = `/auth/key/complete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ecdhCompleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the ECDH key exchange process by generating a server key pair.
         * @summary Initialize key exchange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initKeyExchange: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/key/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DynamicAPIKeyApi - functional programming interface
 */
export const DynamicAPIKeyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DynamicAPIKeyApiAxiosParamCreator(configuration)
    return {
        /**
         * Completes the ECDH key exchange and returns the shared secret (API key).
         * @summary Complete key exchange
         * @param {EcdhCompleteRequest} ecdhCompleteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeKeyExchange(ecdhCompleteRequest: EcdhCompleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeKeyExchange(ecdhCompleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DynamicAPIKeyApi.completeKeyExchange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts the ECDH key exchange process by generating a server key pair.
         * @summary Initialize key exchange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initKeyExchange(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EcdhInitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initKeyExchange(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DynamicAPIKeyApi.initKeyExchange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DynamicAPIKeyApi - factory interface
 */
export const DynamicAPIKeyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DynamicAPIKeyApiFp(configuration)
    return {
        /**
         * Completes the ECDH key exchange and returns the shared secret (API key).
         * @summary Complete key exchange
         * @param {DynamicAPIKeyApiCompleteKeyExchangeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeKeyExchange(requestParameters: DynamicAPIKeyApiCompleteKeyExchangeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyResponse> {
            return localVarFp.completeKeyExchange(requestParameters.ecdhCompleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts the ECDH key exchange process by generating a server key pair.
         * @summary Initialize key exchange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initKeyExchange(options?: RawAxiosRequestConfig): AxiosPromise<EcdhInitResponse> {
            return localVarFp.initKeyExchange(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DynamicAPIKeyApi - interface
 */
export interface DynamicAPIKeyApiInterface {
    /**
     * Completes the ECDH key exchange and returns the shared secret (API key).
     * @summary Complete key exchange
     * @param {DynamicAPIKeyApiCompleteKeyExchangeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    completeKeyExchange(requestParameters: DynamicAPIKeyApiCompleteKeyExchangeRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyResponse>;

    /**
     * Starts the ECDH key exchange process by generating a server key pair.
     * @summary Initialize key exchange
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initKeyExchange(options?: RawAxiosRequestConfig): AxiosPromise<EcdhInitResponse>;

}

/**
 * Request parameters for completeKeyExchange operation in DynamicAPIKeyApi.
 */
export interface DynamicAPIKeyApiCompleteKeyExchangeRequest {
    readonly ecdhCompleteRequest: EcdhCompleteRequest
}

/**
 * DynamicAPIKeyApi - object-oriented interface
 */
export class DynamicAPIKeyApi extends BaseAPI implements DynamicAPIKeyApiInterface {
    /**
     * Completes the ECDH key exchange and returns the shared secret (API key).
     * @summary Complete key exchange
     * @param {DynamicAPIKeyApiCompleteKeyExchangeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public completeKeyExchange(requestParameters: DynamicAPIKeyApiCompleteKeyExchangeRequest, options?: RawAxiosRequestConfig) {
        return DynamicAPIKeyApiFp(this.configuration).completeKeyExchange(requestParameters.ecdhCompleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts the ECDH key exchange process by generating a server key pair.
     * @summary Initialize key exchange
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public initKeyExchange(options?: RawAxiosRequestConfig) {
        return DynamicAPIKeyApiFp(this.configuration).initKeyExchange(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InviteUserApi - axios parameter creator
 */
export const InviteUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {InviteRequest} inviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvite: async (inviteRequest: InviteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteRequest' is not null or undefined
            assertParamExists('createInvite', 'inviteRequest', inviteRequest)
            const localVarPath = `/admin/invites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvite: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteInvite', 'id', id)
            const localVarPath = `/admin/invites/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInvites: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/invites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendInvite: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resendInvite', 'id', id)
            const localVarPath = `/admin/invites/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InviteUserApi - functional programming interface
 */
export const InviteUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InviteUserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {InviteRequest} inviteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInvite(inviteRequest: InviteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInvite(inviteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InviteUserApi.createInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInvite(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInvite(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InviteUserApi.deleteInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllInvites(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InviteDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllInvites(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InviteUserApi.getAllInvites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendInvite(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendInvite(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InviteUserApi.resendInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InviteUserApi - factory interface
 */
export const InviteUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InviteUserApiFp(configuration)
    return {
        /**
         * 
         * @param {InviteUserApiCreateInviteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvite(requestParameters: InviteUserApiCreateInviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<InviteDto> {
            return localVarFp.createInvite(requestParameters.inviteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InviteUserApiDeleteInviteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvite(requestParameters: InviteUserApiDeleteInviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteInvite(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllInvites(options?: RawAxiosRequestConfig): AxiosPromise<Array<InviteDto>> {
            return localVarFp.getAllInvites(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InviteUserApiResendInviteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendInvite(requestParameters: InviteUserApiResendInviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resendInvite(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InviteUserApi - interface
 */
export interface InviteUserApiInterface {
    /**
     * 
     * @param {InviteUserApiCreateInviteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createInvite(requestParameters: InviteUserApiCreateInviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<InviteDto>;

    /**
     * 
     * @param {InviteUserApiDeleteInviteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInvite(requestParameters: InviteUserApiDeleteInviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllInvites(options?: RawAxiosRequestConfig): AxiosPromise<Array<InviteDto>>;

    /**
     * 
     * @param {InviteUserApiResendInviteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resendInvite(requestParameters: InviteUserApiResendInviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * Request parameters for createInvite operation in InviteUserApi.
 */
export interface InviteUserApiCreateInviteRequest {
    readonly inviteRequest: InviteRequest
}

/**
 * Request parameters for deleteInvite operation in InviteUserApi.
 */
export interface InviteUserApiDeleteInviteRequest {
    readonly id: number
}

/**
 * Request parameters for resendInvite operation in InviteUserApi.
 */
export interface InviteUserApiResendInviteRequest {
    readonly id: number
}

/**
 * InviteUserApi - object-oriented interface
 */
export class InviteUserApi extends BaseAPI implements InviteUserApiInterface {
    /**
     * 
     * @param {InviteUserApiCreateInviteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createInvite(requestParameters: InviteUserApiCreateInviteRequest, options?: RawAxiosRequestConfig) {
        return InviteUserApiFp(this.configuration).createInvite(requestParameters.inviteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InviteUserApiDeleteInviteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteInvite(requestParameters: InviteUserApiDeleteInviteRequest, options?: RawAxiosRequestConfig) {
        return InviteUserApiFp(this.configuration).deleteInvite(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getAllInvites(options?: RawAxiosRequestConfig) {
        return InviteUserApiFp(this.configuration).getAllInvites(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InviteUserApiResendInviteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resendInvite(requestParameters: InviteUserApiResendInviteRequest, options?: RawAxiosRequestConfig) {
        return InviteUserApiFp(this.configuration).resendInvite(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentWebhooksApi - axios parameter creator
 */
export const PaymentWebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Receives and processes webhook notifications from Flutterwave to update payment statuses.
         * @summary Handles Flutterwave webhook events
         * @param {string} verifHash Flutterwave signature header for webhook verification
         * @param {object} body Raw JSON payload from Flutterwave. The structure depends on the event type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleFlutterwaveWebhook: async (verifHash: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifHash' is not null or undefined
            assertParamExists('handleFlutterwaveWebhook', 'verifHash', verifHash)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('handleFlutterwaveWebhook', 'body', body)
            const localVarPath = `/api/webhooks/flutterwave`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (verifHash != null) {
                localVarHeaderParameter['verif-hash'] = String(verifHash);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Receives and processes webhook notifications from Paystack to update payment statuses.
         * @summary Handles Paystack webhook events
         * @param {string} xPaystackSignature Paystack signature header for webhook verification
         * @param {object} body Raw JSON payload from Paystack. The structure depends on the event type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handlePaystackWebhook: async (xPaystackSignature: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xPaystackSignature' is not null or undefined
            assertParamExists('handlePaystackWebhook', 'xPaystackSignature', xPaystackSignature)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('handlePaystackWebhook', 'body', body)
            const localVarPath = `/api/webhooks/paystack`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xPaystackSignature != null) {
                localVarHeaderParameter['x-paystack-signature'] = String(xPaystackSignature);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentWebhooksApi - functional programming interface
 */
export const PaymentWebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentWebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Receives and processes webhook notifications from Flutterwave to update payment statuses.
         * @summary Handles Flutterwave webhook events
         * @param {string} verifHash Flutterwave signature header for webhook verification
         * @param {object} body Raw JSON payload from Flutterwave. The structure depends on the event type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleFlutterwaveWebhook(verifHash: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleFlutterwaveWebhook(verifHash, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentWebhooksApi.handleFlutterwaveWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Receives and processes webhook notifications from Paystack to update payment statuses.
         * @summary Handles Paystack webhook events
         * @param {string} xPaystackSignature Paystack signature header for webhook verification
         * @param {object} body Raw JSON payload from Paystack. The structure depends on the event type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handlePaystackWebhook(xPaystackSignature: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handlePaystackWebhook(xPaystackSignature, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentWebhooksApi.handlePaystackWebhook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentWebhooksApi - factory interface
 */
export const PaymentWebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentWebhooksApiFp(configuration)
    return {
        /**
         * Receives and processes webhook notifications from Flutterwave to update payment statuses.
         * @summary Handles Flutterwave webhook events
         * @param {PaymentWebhooksApiHandleFlutterwaveWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleFlutterwaveWebhook(requestParameters: PaymentWebhooksApiHandleFlutterwaveWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.handleFlutterwaveWebhook(requestParameters.verifHash, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Receives and processes webhook notifications from Paystack to update payment statuses.
         * @summary Handles Paystack webhook events
         * @param {PaymentWebhooksApiHandlePaystackWebhookRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handlePaystackWebhook(requestParameters: PaymentWebhooksApiHandlePaystackWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.handlePaystackWebhook(requestParameters.xPaystackSignature, requestParameters.body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentWebhooksApi - interface
 */
export interface PaymentWebhooksApiInterface {
    /**
     * Receives and processes webhook notifications from Flutterwave to update payment statuses.
     * @summary Handles Flutterwave webhook events
     * @param {PaymentWebhooksApiHandleFlutterwaveWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handleFlutterwaveWebhook(requestParameters: PaymentWebhooksApiHandleFlutterwaveWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Receives and processes webhook notifications from Paystack to update payment statuses.
     * @summary Handles Paystack webhook events
     * @param {PaymentWebhooksApiHandlePaystackWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    handlePaystackWebhook(requestParameters: PaymentWebhooksApiHandlePaystackWebhookRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * Request parameters for handleFlutterwaveWebhook operation in PaymentWebhooksApi.
 */
export interface PaymentWebhooksApiHandleFlutterwaveWebhookRequest {
    /**
     * Flutterwave signature header for webhook verification
     */
    readonly verifHash: string

    /**
     * Raw JSON payload from Flutterwave. The structure depends on the event type.
     */
    readonly body: object
}

/**
 * Request parameters for handlePaystackWebhook operation in PaymentWebhooksApi.
 */
export interface PaymentWebhooksApiHandlePaystackWebhookRequest {
    /**
     * Paystack signature header for webhook verification
     */
    readonly xPaystackSignature: string

    /**
     * Raw JSON payload from Paystack. The structure depends on the event type.
     */
    readonly body: object
}

/**
 * PaymentWebhooksApi - object-oriented interface
 */
export class PaymentWebhooksApi extends BaseAPI implements PaymentWebhooksApiInterface {
    /**
     * Receives and processes webhook notifications from Flutterwave to update payment statuses.
     * @summary Handles Flutterwave webhook events
     * @param {PaymentWebhooksApiHandleFlutterwaveWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public handleFlutterwaveWebhook(requestParameters: PaymentWebhooksApiHandleFlutterwaveWebhookRequest, options?: RawAxiosRequestConfig) {
        return PaymentWebhooksApiFp(this.configuration).handleFlutterwaveWebhook(requestParameters.verifHash, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Receives and processes webhook notifications from Paystack to update payment statuses.
     * @summary Handles Paystack webhook events
     * @param {PaymentWebhooksApiHandlePaystackWebhookRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public handlePaystackWebhook(requestParameters: PaymentWebhooksApiHandlePaystackWebhookRequest, options?: RawAxiosRequestConfig) {
        return PaymentWebhooksApiFp(this.configuration).handlePaystackWebhook(requestParameters.xPaystackSignature, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentsApi - axios parameter creator
 */
export const PaymentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of all supported banks for payments.
         * @summary Get list of supported banks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/payments/banks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initializes a new payment transaction with the specified provider or the default provider if none is specified.
         * @summary Initialize a payment
         * @param {InitializePaymentRequest} initializePaymentRequest 
         * @param {string} [provider] The name of the payment provider to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initializePayment: async (initializePaymentRequest: InitializePaymentRequest, provider?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'initializePaymentRequest' is not null or undefined
            assertParamExists('initializePayment', 'initializePaymentRequest', initializePaymentRequest)
            const localVarPath = `/api/payments/initialize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(initializePaymentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentsApi - functional programming interface
 */
export const PaymentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of all supported banks for payments.
         * @summary Get list of supported banks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBanks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BankDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBanks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.getBanks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Initializes a new payment transaction with the specified provider or the default provider if none is specified.
         * @summary Initialize a payment
         * @param {InitializePaymentRequest} initializePaymentRequest 
         * @param {string} [provider] The name of the payment provider to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initializePayment(initializePaymentRequest: InitializePaymentRequest, provider?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InitializePaymentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initializePayment(initializePaymentRequest, provider, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentsApi.initializePayment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentsApi - factory interface
 */
export const PaymentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentsApiFp(configuration)
    return {
        /**
         * Retrieves a list of all supported banks for payments.
         * @summary Get list of supported banks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBanks(options?: RawAxiosRequestConfig): AxiosPromise<Array<BankDto>> {
            return localVarFp.getBanks(options).then((request) => request(axios, basePath));
        },
        /**
         * Initializes a new payment transaction with the specified provider or the default provider if none is specified.
         * @summary Initialize a payment
         * @param {PaymentsApiInitializePaymentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initializePayment(requestParameters: PaymentsApiInitializePaymentRequest, options?: RawAxiosRequestConfig): AxiosPromise<InitializePaymentResponse> {
            return localVarFp.initializePayment(requestParameters.initializePaymentRequest, requestParameters.provider, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentsApi - interface
 */
export interface PaymentsApiInterface {
    /**
     * Retrieves a list of all supported banks for payments.
     * @summary Get list of supported banks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBanks(options?: RawAxiosRequestConfig): AxiosPromise<Array<BankDto>>;

    /**
     * Initializes a new payment transaction with the specified provider or the default provider if none is specified.
     * @summary Initialize a payment
     * @param {PaymentsApiInitializePaymentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initializePayment(requestParameters: PaymentsApiInitializePaymentRequest, options?: RawAxiosRequestConfig): AxiosPromise<InitializePaymentResponse>;

}

/**
 * Request parameters for initializePayment operation in PaymentsApi.
 */
export interface PaymentsApiInitializePaymentRequest {
    readonly initializePaymentRequest: InitializePaymentRequest

    /**
     * The name of the payment provider to use
     */
    readonly provider?: string
}

/**
 * PaymentsApi - object-oriented interface
 */
export class PaymentsApi extends BaseAPI implements PaymentsApiInterface {
    /**
     * Retrieves a list of all supported banks for payments.
     * @summary Get list of supported banks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getBanks(options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).getBanks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initializes a new payment transaction with the specified provider or the default provider if none is specified.
     * @summary Initialize a payment
     * @param {PaymentsApiInitializePaymentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public initializePayment(requestParameters: PaymentsApiInitializePaymentRequest, options?: RawAxiosRequestConfig) {
        return PaymentsApiFp(this.configuration).initializePayment(requestParameters.initializePaymentRequest, requestParameters.provider, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QuidApi - axios parameter creator
 */
export const QuidApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the details of a specific Quid.
         * @summary Get Quid details
         * @param {string} quid The code of the Quid to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuid: async (quid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quid' is not null or undefined
            assertParamExists('getQuid', 'quid', quid)
            const localVarPath = `/quid/{quid}`
                .replace(`{${"quid"}}`, encodeURIComponent(String(quid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a Quid\'s status to active. Requires ADMIN role.
         * @summary Activate a Quid
         * @param {string} quid The code of the Quid to activate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setQuidActive: async (quid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quid' is not null or undefined
            assertParamExists('setQuidActive', 'quid', quid)
            const localVarPath = `/quid/{quid}/status/activate`
                .replace(`{${"quid"}}`, encodeURIComponent(String(quid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the status of a specific Quid.
         * @summary Update Quid status
         * @param {string} quid The code of the Quid to update.
         * @param {QuidStatusDto} quidStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuidStatus: async (quid: string, quidStatusDto: QuidStatusDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quid' is not null or undefined
            assertParamExists('updateQuidStatus', 'quid', quid)
            // verify required parameter 'quidStatusDto' is not null or undefined
            assertParamExists('updateQuidStatus', 'quidStatusDto', quidStatusDto)
            const localVarPath = `/quid/{quid}/status`
                .replace(`{${"quid"}}`, encodeURIComponent(String(quid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(quidStatusDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuidApi - functional programming interface
 */
export const QuidApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuidApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the details of a specific Quid.
         * @summary Get Quid details
         * @param {string} quid The code of the Quid to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getQuid(quid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quid>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getQuid(quid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuidApi.getQuid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets a Quid\'s status to active. Requires ADMIN role.
         * @summary Activate a Quid
         * @param {string} quid The code of the Quid to activate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setQuidActive(quid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuiikaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setQuidActive(quid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuidApi.setQuidActive']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the status of a specific Quid.
         * @summary Update Quid status
         * @param {string} quid The code of the Quid to update.
         * @param {QuidStatusDto} quidStatusDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateQuidStatus(quid: string, quidStatusDto: QuidStatusDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuiikaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateQuidStatus(quid, quidStatusDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['QuidApi.updateQuidStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * QuidApi - factory interface
 */
export const QuidApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuidApiFp(configuration)
    return {
        /**
         * Retrieves the details of a specific Quid.
         * @summary Get Quid details
         * @param {QuidApiGetQuidRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuid(requestParameters: QuidApiGetQuidRequest, options?: RawAxiosRequestConfig): AxiosPromise<Quid> {
            return localVarFp.getQuid(requestParameters.quid, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets a Quid\'s status to active. Requires ADMIN role.
         * @summary Activate a Quid
         * @param {QuidApiSetQuidActiveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setQuidActive(requestParameters: QuidApiSetQuidActiveRequest, options?: RawAxiosRequestConfig): AxiosPromise<QuiikaResponse> {
            return localVarFp.setQuidActive(requestParameters.quid, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the status of a specific Quid.
         * @summary Update Quid status
         * @param {QuidApiUpdateQuidStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateQuidStatus(requestParameters: QuidApiUpdateQuidStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<QuiikaResponse> {
            return localVarFp.updateQuidStatus(requestParameters.quid, requestParameters.quidStatusDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuidApi - interface
 */
export interface QuidApiInterface {
    /**
     * Retrieves the details of a specific Quid.
     * @summary Get Quid details
     * @param {QuidApiGetQuidRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQuid(requestParameters: QuidApiGetQuidRequest, options?: RawAxiosRequestConfig): AxiosPromise<Quid>;

    /**
     * Sets a Quid\'s status to active. Requires ADMIN role.
     * @summary Activate a Quid
     * @param {QuidApiSetQuidActiveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setQuidActive(requestParameters: QuidApiSetQuidActiveRequest, options?: RawAxiosRequestConfig): AxiosPromise<QuiikaResponse>;

    /**
     * Updates the status of a specific Quid.
     * @summary Update Quid status
     * @param {QuidApiUpdateQuidStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateQuidStatus(requestParameters: QuidApiUpdateQuidStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<QuiikaResponse>;

}

/**
 * Request parameters for getQuid operation in QuidApi.
 */
export interface QuidApiGetQuidRequest {
    /**
     * The code of the Quid to retrieve.
     */
    readonly quid: string
}

/**
 * Request parameters for setQuidActive operation in QuidApi.
 */
export interface QuidApiSetQuidActiveRequest {
    /**
     * The code of the Quid to activate.
     */
    readonly quid: string
}

/**
 * Request parameters for updateQuidStatus operation in QuidApi.
 */
export interface QuidApiUpdateQuidStatusRequest {
    /**
     * The code of the Quid to update.
     */
    readonly quid: string

    readonly quidStatusDto: QuidStatusDto
}

/**
 * QuidApi - object-oriented interface
 */
export class QuidApi extends BaseAPI implements QuidApiInterface {
    /**
     * Retrieves the details of a specific Quid.
     * @summary Get Quid details
     * @param {QuidApiGetQuidRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getQuid(requestParameters: QuidApiGetQuidRequest, options?: RawAxiosRequestConfig) {
        return QuidApiFp(this.configuration).getQuid(requestParameters.quid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets a Quid\'s status to active. Requires ADMIN role.
     * @summary Activate a Quid
     * @param {QuidApiSetQuidActiveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public setQuidActive(requestParameters: QuidApiSetQuidActiveRequest, options?: RawAxiosRequestConfig) {
        return QuidApiFp(this.configuration).setQuidActive(requestParameters.quid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the status of a specific Quid.
     * @summary Update Quid status
     * @param {QuidApiUpdateQuidStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateQuidStatus(requestParameters: QuidApiUpdateQuidStatusRequest, options?: RawAxiosRequestConfig) {
        return QuidApiFp(this.configuration).updateQuidStatus(requestParameters.quid, requestParameters.quidStatusDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RulesApi - axios parameter creator
 */
export const RulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of all existing claim rules.
         * @summary Get all rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allRules: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attempts to claim a Quid based on its associated rules.
         * @summary Attempt to claim a Quid
         * @param {string} quid The Quid to attempt to claim.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claim: async (quid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quid' is not null or undefined
            assertParamExists('claim', 'quid', quid)
            const localVarPath = `/rules/claim`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (quid !== undefined) {
                localVarQueryParameter['quid'] = quid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new claim rule with specified conditions and splits.
         * @summary Create a new rule
         * @param {RuleDTO} ruleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRule: async (ruleDTO: RuleDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleDTO' is not null or undefined
            assertParamExists('createRule', 'ruleDTO', ruleDTO)
            const localVarPath = `/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ruleDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of a rule associated with a specific Quid.
         * @summary Get a rule by Quid
         * @param {string} quid The Quid associated with the rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule: async (quid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quid' is not null or undefined
            assertParamExists('getRule', 'quid', quid)
            const localVarPath = `/rules/{quid}`
                .replace(`{${"quid"}}`, encodeURIComponent(String(quid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RulesApi - functional programming interface
 */
export const RulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of all existing claim rules.
         * @summary Get all rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async allRules(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Rule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allRules(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.allRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Attempts to claim a Quid based on its associated rules.
         * @summary Attempt to claim a Quid
         * @param {string} quid The Quid to attempt to claim.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async claim(quid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuiikaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.claim(quid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.claim']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new claim rule with specified conditions and splits.
         * @summary Create a new rule
         * @param {RuleDTO} ruleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRule(ruleDTO: RuleDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRule(ruleDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.createRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the details of a rule associated with a specific Quid.
         * @summary Get a rule by Quid
         * @param {string} quid The Quid associated with the rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRule(quid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRule(quid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RulesApi.getRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RulesApi - factory interface
 */
export const RulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RulesApiFp(configuration)
    return {
        /**
         * Retrieves a list of all existing claim rules.
         * @summary Get all rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        allRules(options?: RawAxiosRequestConfig): AxiosPromise<Array<Rule>> {
            return localVarFp.allRules(options).then((request) => request(axios, basePath));
        },
        /**
         * Attempts to claim a Quid based on its associated rules.
         * @summary Attempt to claim a Quid
         * @param {RulesApiClaimRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claim(requestParameters: RulesApiClaimRequest, options?: RawAxiosRequestConfig): AxiosPromise<QuiikaResponse> {
            return localVarFp.claim(requestParameters.quid, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new claim rule with specified conditions and splits.
         * @summary Create a new rule
         * @param {RulesApiCreateRuleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRule(requestParameters: RulesApiCreateRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<Rule> {
            return localVarFp.createRule(requestParameters.ruleDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of a rule associated with a specific Quid.
         * @summary Get a rule by Quid
         * @param {RulesApiGetRuleRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRule(requestParameters: RulesApiGetRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<Rule> {
            return localVarFp.getRule(requestParameters.quid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RulesApi - interface
 */
export interface RulesApiInterface {
    /**
     * Retrieves a list of all existing claim rules.
     * @summary Get all rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    allRules(options?: RawAxiosRequestConfig): AxiosPromise<Array<Rule>>;

    /**
     * Attempts to claim a Quid based on its associated rules.
     * @summary Attempt to claim a Quid
     * @param {RulesApiClaimRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    claim(requestParameters: RulesApiClaimRequest, options?: RawAxiosRequestConfig): AxiosPromise<QuiikaResponse>;

    /**
     * Creates a new claim rule with specified conditions and splits.
     * @summary Create a new rule
     * @param {RulesApiCreateRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRule(requestParameters: RulesApiCreateRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<Rule>;

    /**
     * Retrieves the details of a rule associated with a specific Quid.
     * @summary Get a rule by Quid
     * @param {RulesApiGetRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRule(requestParameters: RulesApiGetRuleRequest, options?: RawAxiosRequestConfig): AxiosPromise<Rule>;

}

/**
 * Request parameters for claim operation in RulesApi.
 */
export interface RulesApiClaimRequest {
    /**
     * The Quid to attempt to claim.
     */
    readonly quid: string
}

/**
 * Request parameters for createRule operation in RulesApi.
 */
export interface RulesApiCreateRuleRequest {
    readonly ruleDTO: RuleDTO
}

/**
 * Request parameters for getRule operation in RulesApi.
 */
export interface RulesApiGetRuleRequest {
    /**
     * The Quid associated with the rule.
     */
    readonly quid: string
}

/**
 * RulesApi - object-oriented interface
 */
export class RulesApi extends BaseAPI implements RulesApiInterface {
    /**
     * Retrieves a list of all existing claim rules.
     * @summary Get all rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public allRules(options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).allRules(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attempts to claim a Quid based on its associated rules.
     * @summary Attempt to claim a Quid
     * @param {RulesApiClaimRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public claim(requestParameters: RulesApiClaimRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).claim(requestParameters.quid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new claim rule with specified conditions and splits.
     * @summary Create a new rule
     * @param {RulesApiCreateRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public createRule(requestParameters: RulesApiCreateRuleRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).createRule(requestParameters.ruleDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of a rule associated with a specific Quid.
     * @summary Get a rule by Quid
     * @param {RulesApiGetRuleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getRule(requestParameters: RulesApiGetRuleRequest, options?: RawAxiosRequestConfig) {
        return RulesApiFp(this.configuration).getRule(requestParameters.quid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServerSentEventsApi - axios parameter creator
 */
export const ServerSentEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Establishes a Server-Sent Events (SSE) connection for a given session ID to receive real-time updates.
         * @summary Subscribe to an event stream
         * @param {string} sessionId The session ID to connect with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connect: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('connect', 'sessionId', sessionId)
            const localVarPath = `/sse/connect/{sessionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes the Server-Sent Events (SSE) connection for the given session ID and cleans up resources.
         * @summary Disconnect SSE connection
         * @param {string} sessionId The session ID to disconnect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnect: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('disconnect', 'sessionId', sessionId)
            const localVarPath = `/sse/disconnect/{sessionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a message to a specific user via SSE. This endpoint is intended for internal testing and debugging purposes.
         * @summary Send a message to a user (For internal testing)
         * @param {string} userId The ID of the user to send the message to
         * @param {string} message The message content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessageToUser: async (userId: string, message: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('sendMessageToUser', 'userId', userId)
            // verify required parameter 'message' is not null or undefined
            assertParamExists('sendMessageToUser', 'message', message)
            const localVarPath = `/sse/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (message !== undefined) {
                localVarQueryParameter['message'] = message;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerSentEventsApi - functional programming interface
 */
export const ServerSentEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerSentEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Establishes a Server-Sent Events (SSE) connection for a given session ID to receive real-time updates.
         * @summary Subscribe to an event stream
         * @param {string} sessionId The session ID to connect with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connect(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connect(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerSentEventsApi.connect']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes the Server-Sent Events (SSE) connection for the given session ID and cleans up resources.
         * @summary Disconnect SSE connection
         * @param {string} sessionId The session ID to disconnect
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disconnect(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disconnect(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerSentEventsApi.disconnect']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends a message to a specific user via SSE. This endpoint is intended for internal testing and debugging purposes.
         * @summary Send a message to a user (For internal testing)
         * @param {string} userId The ID of the user to send the message to
         * @param {string} message The message content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMessageToUser(userId: string, message: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuiikaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendMessageToUser(userId, message, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ServerSentEventsApi.sendMessageToUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ServerSentEventsApi - factory interface
 */
export const ServerSentEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerSentEventsApiFp(configuration)
    return {
        /**
         * Establishes a Server-Sent Events (SSE) connection for a given session ID to receive real-time updates.
         * @summary Subscribe to an event stream
         * @param {ServerSentEventsApiConnectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connect(requestParameters: ServerSentEventsApiConnectRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.connect(requestParameters.sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes the Server-Sent Events (SSE) connection for the given session ID and cleans up resources.
         * @summary Disconnect SSE connection
         * @param {ServerSentEventsApiDisconnectRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disconnect(requestParameters: ServerSentEventsApiDisconnectRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.disconnect(requestParameters.sessionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a message to a specific user via SSE. This endpoint is intended for internal testing and debugging purposes.
         * @summary Send a message to a user (For internal testing)
         * @param {ServerSentEventsApiSendMessageToUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessageToUser(requestParameters: ServerSentEventsApiSendMessageToUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<QuiikaResponse> {
            return localVarFp.sendMessageToUser(requestParameters.userId, requestParameters.message, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerSentEventsApi - interface
 */
export interface ServerSentEventsApiInterface {
    /**
     * Establishes a Server-Sent Events (SSE) connection for a given session ID to receive real-time updates.
     * @summary Subscribe to an event stream
     * @param {ServerSentEventsApiConnectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    connect(requestParameters: ServerSentEventsApiConnectRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Removes the Server-Sent Events (SSE) connection for the given session ID and cleans up resources.
     * @summary Disconnect SSE connection
     * @param {ServerSentEventsApiDisconnectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disconnect(requestParameters: ServerSentEventsApiDisconnectRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Sends a message to a specific user via SSE. This endpoint is intended for internal testing and debugging purposes.
     * @summary Send a message to a user (For internal testing)
     * @param {ServerSentEventsApiSendMessageToUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendMessageToUser(requestParameters: ServerSentEventsApiSendMessageToUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<QuiikaResponse>;

}

/**
 * Request parameters for connect operation in ServerSentEventsApi.
 */
export interface ServerSentEventsApiConnectRequest {
    /**
     * The session ID to connect with
     */
    readonly sessionId: string
}

/**
 * Request parameters for disconnect operation in ServerSentEventsApi.
 */
export interface ServerSentEventsApiDisconnectRequest {
    /**
     * The session ID to disconnect
     */
    readonly sessionId: string
}

/**
 * Request parameters for sendMessageToUser operation in ServerSentEventsApi.
 */
export interface ServerSentEventsApiSendMessageToUserRequest {
    /**
     * The ID of the user to send the message to
     */
    readonly userId: string

    /**
     * The message content
     */
    readonly message: string
}

/**
 * ServerSentEventsApi - object-oriented interface
 */
export class ServerSentEventsApi extends BaseAPI implements ServerSentEventsApiInterface {
    /**
     * Establishes a Server-Sent Events (SSE) connection for a given session ID to receive real-time updates.
     * @summary Subscribe to an event stream
     * @param {ServerSentEventsApiConnectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public connect(requestParameters: ServerSentEventsApiConnectRequest, options?: RawAxiosRequestConfig) {
        return ServerSentEventsApiFp(this.configuration).connect(requestParameters.sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes the Server-Sent Events (SSE) connection for the given session ID and cleans up resources.
     * @summary Disconnect SSE connection
     * @param {ServerSentEventsApiDisconnectRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public disconnect(requestParameters: ServerSentEventsApiDisconnectRequest, options?: RawAxiosRequestConfig) {
        return ServerSentEventsApiFp(this.configuration).disconnect(requestParameters.sessionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends a message to a specific user via SSE. This endpoint is intended for internal testing and debugging purposes.
     * @summary Send a message to a user (For internal testing)
     * @param {ServerSentEventsApiSendMessageToUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public sendMessageToUser(requestParameters: ServerSentEventsApiSendMessageToUserRequest, options?: RawAxiosRequestConfig) {
        return ServerSentEventsApiFp(this.configuration).sendMessageToUser(requestParameters.userId, requestParameters.message, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SessionManagementApi - axios parameter creator
 */
export const SessionManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get active sessions for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveSessions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/sessions/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get active session count for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/sessions/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all active sessions for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSessions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke all sessions for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeAllSessions: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/sessions/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke all other sessions except current one
         * @param {string} authorization The Authorization header containing the current session\&#39;s JWT.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeOtherSessions: async (authorization: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('revokeOtherSessions', 'authorization', authorization)
            const localVarPath = `/auth/sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revoke a specific session
         * @param {string} sessionId The ID of the session to revoke.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeSession: async (sessionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sessionId' is not null or undefined
            assertParamExists('revokeSession', 'sessionId', sessionId)
            const localVarPath = `/auth/sessions/{sessionId}`
                .replace(`{${"sessionId"}}`, encodeURIComponent(String(sessionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SessionManagementApi - functional programming interface
 */
export const SessionManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SessionManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get active sessions for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveSessions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSessionDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveSessions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionManagementApi.getActiveSessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get active session count for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSessionCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SessionCountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSessionCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionManagementApi.getSessionCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all active sessions for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSessions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSessionDetails>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSessions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionManagementApi.getUserSessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Revoke all sessions for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeAllSessions(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeAllSessions(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionManagementApi.revokeAllSessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Revoke all other sessions except current one
         * @param {string} authorization The Authorization header containing the current session\&#39;s JWT.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeOtherSessions(authorization: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeOtherSessions(authorization, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionManagementApi.revokeOtherSessions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Revoke a specific session
         * @param {string} sessionId The ID of the session to revoke.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeSession(sessionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeSession(sessionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SessionManagementApi.revokeSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SessionManagementApi - factory interface
 */
export const SessionManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SessionManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary Get active sessions for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveSessions(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserSessionDetails>> {
            return localVarFp.getActiveSessions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get active session count for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSessionCount(options?: RawAxiosRequestConfig): AxiosPromise<SessionCountResponse> {
            return localVarFp.getSessionCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all active sessions for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSessions(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserSessionDetails>> {
            return localVarFp.getUserSessions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke all sessions for current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeAllSessions(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.revokeAllSessions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke all other sessions except current one
         * @param {SessionManagementApiRevokeOtherSessionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeOtherSessions(requestParameters: SessionManagementApiRevokeOtherSessionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.revokeOtherSessions(requestParameters.authorization, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Revoke a specific session
         * @param {SessionManagementApiRevokeSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeSession(requestParameters: SessionManagementApiRevokeSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.revokeSession(requestParameters.sessionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SessionManagementApi - interface
 */
export interface SessionManagementApiInterface {
    /**
     * 
     * @summary Get active sessions for current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveSessions(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserSessionDetails>>;

    /**
     * 
     * @summary Get active session count for current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSessionCount(options?: RawAxiosRequestConfig): AxiosPromise<SessionCountResponse>;

    /**
     * 
     * @summary Get all active sessions for current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserSessions(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserSessionDetails>>;

    /**
     * 
     * @summary Revoke all sessions for current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeAllSessions(options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Revoke all other sessions except current one
     * @param {SessionManagementApiRevokeOtherSessionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeOtherSessions(requestParameters: SessionManagementApiRevokeOtherSessionsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Revoke a specific session
     * @param {SessionManagementApiRevokeSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    revokeSession(requestParameters: SessionManagementApiRevokeSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * Request parameters for revokeOtherSessions operation in SessionManagementApi.
 */
export interface SessionManagementApiRevokeOtherSessionsRequest {
    /**
     * The Authorization header containing the current session\&#39;s JWT.
     */
    readonly authorization: string
}

/**
 * Request parameters for revokeSession operation in SessionManagementApi.
 */
export interface SessionManagementApiRevokeSessionRequest {
    /**
     * The ID of the session to revoke.
     */
    readonly sessionId: string
}

/**
 * SessionManagementApi - object-oriented interface
 */
export class SessionManagementApi extends BaseAPI implements SessionManagementApiInterface {
    /**
     * 
     * @summary Get active sessions for current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getActiveSessions(options?: RawAxiosRequestConfig) {
        return SessionManagementApiFp(this.configuration).getActiveSessions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get active session count for current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getSessionCount(options?: RawAxiosRequestConfig) {
        return SessionManagementApiFp(this.configuration).getSessionCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all active sessions for current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getUserSessions(options?: RawAxiosRequestConfig) {
        return SessionManagementApiFp(this.configuration).getUserSessions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke all sessions for current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public revokeAllSessions(options?: RawAxiosRequestConfig) {
        return SessionManagementApiFp(this.configuration).revokeAllSessions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke all other sessions except current one
     * @param {SessionManagementApiRevokeOtherSessionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public revokeOtherSessions(requestParameters: SessionManagementApiRevokeOtherSessionsRequest, options?: RawAxiosRequestConfig) {
        return SessionManagementApiFp(this.configuration).revokeOtherSessions(requestParameters.authorization, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Revoke a specific session
     * @param {SessionManagementApiRevokeSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public revokeSession(requestParameters: SessionManagementApiRevokeSessionRequest, options?: RawAxiosRequestConfig) {
        return SessionManagementApiFp(this.configuration).revokeSession(requestParameters.sessionId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TransactionsApi - axios parameter creator
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of supported banks for payments.
         * @summary Get list of banks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions/banks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all transactions.
         * @summary Find all transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves transaction details using its ID.
         * @summary Find transaction by ID
         * @param {string} transactionId Unique transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTransaction: async (transactionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('findTransaction', 'transactionId', transactionId)
            const localVarPath = `/transactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves transaction details using its reference.
         * @summary Find transaction by reference
         * @param {string} ref Payment reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTransactionByRef: async (ref: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ref' is not null or undefined
            assertParamExists('findTransactionByRef', 'ref', ref)
            const localVarPath = `/transactions/reference/{ref}`
                .replace(`{${"ref"}}`, encodeURIComponent(String(ref)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates and initializes a new transaction.
         * @summary Initialize a transaction
         * @param {TransactionDto} transactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initTransaction: async (transactionDto: TransactionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionDto' is not null or undefined
            assertParamExists('initTransaction', 'transactionDto', transactionDto)
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies bank account details and returns the account holder\'s name.
         * @summary Resolve bank account name
         * @param {ResolveBank} resolveBank 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveBank: async (resolveBank: ResolveBank, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resolveBank' is not null or undefined
            assertParamExists('resolveBank', 'resolveBank', resolveBank)
            const localVarPath = `/transactions/banks/resolve-name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resolveBank, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies the transaction associated with a Quid.
         * @summary Verify a Quid transaction
         * @param {string} quid Quid identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyQuidTransaction: async (quid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quid' is not null or undefined
            assertParamExists('verifyQuidTransaction', 'quid', quid)
            const localVarPath = `/transactions/quid/{quid}/verify`
                .replace(`{${"quid"}}`, encodeURIComponent(String(quid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves transaction details using a Quid.
         * @summary Find transaction by Quid
         * @param {string} quid Quid identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyTransaction: async (quid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quid' is not null or undefined
            assertParamExists('verifyTransaction', 'quid', quid)
            const localVarPath = `/transactions/verify/{quid}`
                .replace(`{${"quid"}}`, encodeURIComponent(String(quid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates a withdrawal process for a given Quid.
         * @summary Withdraw from a Quid
         * @param {string} quid Quid identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdraw: async (quid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quid' is not null or undefined
            assertParamExists('withdraw', 'quid', quid)
            const localVarPath = `/transactions/withdraw/{quid}`
                .replace(`{${"quid"}}`, encodeURIComponent(String(quid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of supported banks for payments.
         * @summary Get list of banks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async banks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankDto<any>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.banks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.banks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of all transactions.
         * @summary Find all transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDto<any>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.findAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves transaction details using its ID.
         * @summary Find transaction by ID
         * @param {string} transactionId Unique transaction ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTransaction(transactionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTransaction(transactionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.findTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves transaction details using its reference.
         * @summary Find transaction by reference
         * @param {string} ref Payment reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTransactionByRef(ref: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTransactionByRef(ref, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.findTransactionByRef']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates and initializes a new transaction.
         * @summary Initialize a transaction
         * @param {TransactionDto} transactionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initTransaction(transactionDto: TransactionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initTransaction(transactionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.initTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verifies bank account details and returns the account holder\'s name.
         * @summary Resolve bank account name
         * @param {ResolveBank} resolveBank 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resolveBank(resolveBank: ResolveBank, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResolveBank>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resolveBank(resolveBank, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.resolveBank']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verifies the transaction associated with a Quid.
         * @summary Verify a Quid transaction
         * @param {string} quid Quid identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyQuidTransaction(quid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuidClaimResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyQuidTransaction(quid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.verifyQuidTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves transaction details using a Quid.
         * @summary Find transaction by Quid
         * @param {string} quid Quid identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyTransaction(quid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyTransaction(quid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.verifyTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Initiates a withdrawal process for a given Quid.
         * @summary Withdraw from a Quid
         * @param {string} quid Quid identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdraw(quid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdraw(quid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TransactionsApi.withdraw']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TransactionsApi - factory interface
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Retrieves a list of supported banks for payments.
         * @summary Get list of banks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        banks(options?: RawAxiosRequestConfig): AxiosPromise<BankDto<any>> {
            return localVarFp.banks(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all transactions.
         * @summary Find all transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAll(options?: RawAxiosRequestConfig): AxiosPromise<TransactionDto<any>> {
            return localVarFp.findAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves transaction details using its ID.
         * @summary Find transaction by ID
         * @param {TransactionsApiFindTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTransaction(requestParameters: TransactionsApiFindTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionDto> {
            return localVarFp.findTransaction(requestParameters.transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves transaction details using its reference.
         * @summary Find transaction by reference
         * @param {TransactionsApiFindTransactionByRefRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTransactionByRef(requestParameters: TransactionsApiFindTransactionByRefRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionDto> {
            return localVarFp.findTransactionByRef(requestParameters.ref, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates and initializes a new transaction.
         * @summary Initialize a transaction
         * @param {TransactionsApiInitTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initTransaction(requestParameters: TransactionsApiInitTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionDto> {
            return localVarFp.initTransaction(requestParameters.transactionDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies bank account details and returns the account holder\'s name.
         * @summary Resolve bank account name
         * @param {TransactionsApiResolveBankRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolveBank(requestParameters: TransactionsApiResolveBankRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResolveBank> {
            return localVarFp.resolveBank(requestParameters.resolveBank, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies the transaction associated with a Quid.
         * @summary Verify a Quid transaction
         * @param {TransactionsApiVerifyQuidTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyQuidTransaction(requestParameters: TransactionsApiVerifyQuidTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<QuidClaimResponse> {
            return localVarFp.verifyQuidTransaction(requestParameters.quid, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves transaction details using a Quid.
         * @summary Find transaction by Quid
         * @param {TransactionsApiVerifyTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyTransaction(requestParameters: TransactionsApiVerifyTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionDto> {
            return localVarFp.verifyTransaction(requestParameters.quid, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates a withdrawal process for a given Quid.
         * @summary Withdraw from a Quid
         * @param {TransactionsApiWithdrawRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdraw(requestParameters: TransactionsApiWithdrawRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.withdraw(requestParameters.quid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - interface
 */
export interface TransactionsApiInterface {
    /**
     * Retrieves a list of supported banks for payments.
     * @summary Get list of banks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    banks(options?: RawAxiosRequestConfig): AxiosPromise<BankDto<any>>;

    /**
     * Retrieves a list of all transactions.
     * @summary Find all transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAll(options?: RawAxiosRequestConfig): AxiosPromise<TransactionDto<any>>;

    /**
     * Retrieves transaction details using its ID.
     * @summary Find transaction by ID
     * @param {TransactionsApiFindTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findTransaction(requestParameters: TransactionsApiFindTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionDto>;

    /**
     * Retrieves transaction details using its reference.
     * @summary Find transaction by reference
     * @param {TransactionsApiFindTransactionByRefRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findTransactionByRef(requestParameters: TransactionsApiFindTransactionByRefRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionDto>;

    /**
     * Creates and initializes a new transaction.
     * @summary Initialize a transaction
     * @param {TransactionsApiInitTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initTransaction(requestParameters: TransactionsApiInitTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionDto>;

    /**
     * Verifies bank account details and returns the account holder\'s name.
     * @summary Resolve bank account name
     * @param {TransactionsApiResolveBankRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resolveBank(requestParameters: TransactionsApiResolveBankRequest, options?: RawAxiosRequestConfig): AxiosPromise<ResolveBank>;

    /**
     * Verifies the transaction associated with a Quid.
     * @summary Verify a Quid transaction
     * @param {TransactionsApiVerifyQuidTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyQuidTransaction(requestParameters: TransactionsApiVerifyQuidTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<QuidClaimResponse>;

    /**
     * Retrieves transaction details using a Quid.
     * @summary Find transaction by Quid
     * @param {TransactionsApiVerifyTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyTransaction(requestParameters: TransactionsApiVerifyTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionDto>;

    /**
     * Initiates a withdrawal process for a given Quid.
     * @summary Withdraw from a Quid
     * @param {TransactionsApiWithdrawRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    withdraw(requestParameters: TransactionsApiWithdrawRequest, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * Request parameters for findTransaction operation in TransactionsApi.
 */
export interface TransactionsApiFindTransactionRequest {
    /**
     * Unique transaction ID
     */
    readonly transactionId: string
}

/**
 * Request parameters for findTransactionByRef operation in TransactionsApi.
 */
export interface TransactionsApiFindTransactionByRefRequest {
    /**
     * Payment reference
     */
    readonly ref: string
}

/**
 * Request parameters for initTransaction operation in TransactionsApi.
 */
export interface TransactionsApiInitTransactionRequest {
    readonly transactionDto: TransactionDto
}

/**
 * Request parameters for resolveBank operation in TransactionsApi.
 */
export interface TransactionsApiResolveBankRequest {
    readonly resolveBank: ResolveBank
}

/**
 * Request parameters for verifyQuidTransaction operation in TransactionsApi.
 */
export interface TransactionsApiVerifyQuidTransactionRequest {
    /**
     * Quid identifier
     */
    readonly quid: string
}

/**
 * Request parameters for verifyTransaction operation in TransactionsApi.
 */
export interface TransactionsApiVerifyTransactionRequest {
    /**
     * Quid identifier
     */
    readonly quid: string
}

/**
 * Request parameters for withdraw operation in TransactionsApi.
 */
export interface TransactionsApiWithdrawRequest {
    /**
     * Quid identifier
     */
    readonly quid: string
}

/**
 * TransactionsApi - object-oriented interface
 */
export class TransactionsApi extends BaseAPI implements TransactionsApiInterface {
    /**
     * Retrieves a list of supported banks for payments.
     * @summary Get list of banks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public banks(options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).banks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all transactions.
     * @summary Find all transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findAll(options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).findAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves transaction details using its ID.
     * @summary Find transaction by ID
     * @param {TransactionsApiFindTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findTransaction(requestParameters: TransactionsApiFindTransactionRequest, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).findTransaction(requestParameters.transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves transaction details using its reference.
     * @summary Find transaction by reference
     * @param {TransactionsApiFindTransactionByRefRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public findTransactionByRef(requestParameters: TransactionsApiFindTransactionByRefRequest, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).findTransactionByRef(requestParameters.ref, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates and initializes a new transaction.
     * @summary Initialize a transaction
     * @param {TransactionsApiInitTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public initTransaction(requestParameters: TransactionsApiInitTransactionRequest, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).initTransaction(requestParameters.transactionDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies bank account details and returns the account holder\'s name.
     * @summary Resolve bank account name
     * @param {TransactionsApiResolveBankRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public resolveBank(requestParameters: TransactionsApiResolveBankRequest, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).resolveBank(requestParameters.resolveBank, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies the transaction associated with a Quid.
     * @summary Verify a Quid transaction
     * @param {TransactionsApiVerifyQuidTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public verifyQuidTransaction(requestParameters: TransactionsApiVerifyQuidTransactionRequest, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).verifyQuidTransaction(requestParameters.quid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves transaction details using a Quid.
     * @summary Find transaction by Quid
     * @param {TransactionsApiVerifyTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public verifyTransaction(requestParameters: TransactionsApiVerifyTransactionRequest, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).verifyTransaction(requestParameters.quid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates a withdrawal process for a given Quid.
     * @summary Withdraw from a Quid
     * @param {TransactionsApiWithdrawRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public withdraw(requestParameters: TransactionsApiWithdrawRequest, options?: RawAxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).withdraw(requestParameters.quid, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WelcomeApi - axios parameter creator
 */
export const WelcomeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Displays a simple HTML welcome page with application info.
         * @summary Show welcome page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        welcome: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WelcomeApi - functional programming interface
 */
export const WelcomeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WelcomeApiAxiosParamCreator(configuration)
    return {
        /**
         * Displays a simple HTML welcome page with application info.
         * @summary Show welcome page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async welcome(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.welcome(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WelcomeApi.welcome']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WelcomeApi - factory interface
 */
export const WelcomeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WelcomeApiFp(configuration)
    return {
        /**
         * Displays a simple HTML welcome page with application info.
         * @summary Show welcome page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        welcome(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.welcome(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WelcomeApi - interface
 */
export interface WelcomeApiInterface {
    /**
     * Displays a simple HTML welcome page with application info.
     * @summary Show welcome page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    welcome(options?: RawAxiosRequestConfig): AxiosPromise<string>;

}

/**
 * WelcomeApi - object-oriented interface
 */
export class WelcomeApi extends BaseAPI implements WelcomeApiInterface {
    /**
     * Displays a simple HTML welcome page with application info.
     * @summary Show welcome page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public welcome(options?: RawAxiosRequestConfig) {
        return WelcomeApiFp(this.configuration).welcome(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WithdrawalRequestsApi - axios parameter creator
 */
export const WithdrawalRequestsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of all withdrawal requests.
         * @summary Get all withdrawal requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAllRequest: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/withdrawal-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a specific withdrawal request using its associated Quid.
         * @summary Get a withdrawal request by Quid
         * @param {string} quid The Quid associated with the withdrawal request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRequest: async (quid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'quid' is not null or undefined
            assertParamExists('fetchRequest', 'quid', quid)
            const localVarPath = `/withdrawal-request/{quid}`
                .replace(`{${"quid"}}`, encodeURIComponent(String(quid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new withdrawal request for a user.
         * @summary Initiate a withdrawal request
         * @param {WithdrawalRequest} withdrawalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateRequest: async (withdrawalRequest: WithdrawalRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalRequest' is not null or undefined
            assertParamExists('initiateRequest', 'withdrawalRequest', withdrawalRequest)
            const localVarPath = `/withdrawal-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawalRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing withdrawal request.
         * @summary Update a withdrawal request
         * @param {WithdrawalUpdateDto} withdrawalUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateRequest1: async (withdrawalUpdateDto: WithdrawalUpdateDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalUpdateDto' is not null or undefined
            assertParamExists('initiateRequest1', 'withdrawalUpdateDto', withdrawalUpdateDto)
            const localVarPath = `/withdrawal-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawalUpdateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WithdrawalRequestsApi - functional programming interface
 */
export const WithdrawalRequestsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WithdrawalRequestsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of all withdrawal requests.
         * @summary Get all withdrawal requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchAllRequest(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WithdrawalRequest>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchAllRequest(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WithdrawalRequestsApi.fetchAllRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a specific withdrawal request using its associated Quid.
         * @summary Get a withdrawal request by Quid
         * @param {string} quid The Quid associated with the withdrawal request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRequest(quid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRequest(quid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WithdrawalRequestsApi.fetchRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new withdrawal request for a user.
         * @summary Initiate a withdrawal request
         * @param {WithdrawalRequest} withdrawalRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateRequest(withdrawalRequest: WithdrawalRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuiikaResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateRequest(withdrawalRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WithdrawalRequestsApi.initiateRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates an existing withdrawal request.
         * @summary Update a withdrawal request
         * @param {WithdrawalUpdateDto} withdrawalUpdateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initiateRequest1(withdrawalUpdateDto: WithdrawalUpdateDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initiateRequest1(withdrawalUpdateDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WithdrawalRequestsApi.initiateRequest1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WithdrawalRequestsApi - factory interface
 */
export const WithdrawalRequestsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WithdrawalRequestsApiFp(configuration)
    return {
        /**
         * Retrieves a list of all withdrawal requests.
         * @summary Get all withdrawal requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAllRequest(options?: RawAxiosRequestConfig): AxiosPromise<Array<WithdrawalRequest>> {
            return localVarFp.fetchAllRequest(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a specific withdrawal request using its associated Quid.
         * @summary Get a withdrawal request by Quid
         * @param {WithdrawalRequestsApiFetchRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRequest(requestParameters: WithdrawalRequestsApiFetchRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<WithdrawalRequest> {
            return localVarFp.fetchRequest(requestParameters.quid, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new withdrawal request for a user.
         * @summary Initiate a withdrawal request
         * @param {WithdrawalRequestsApiInitiateRequestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateRequest(requestParameters: WithdrawalRequestsApiInitiateRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<QuiikaResponse> {
            return localVarFp.initiateRequest(requestParameters.withdrawalRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing withdrawal request.
         * @summary Update a withdrawal request
         * @param {WithdrawalRequestsApiInitiateRequest1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initiateRequest1(requestParameters: WithdrawalRequestsApiInitiateRequest1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.initiateRequest1(requestParameters.withdrawalUpdateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WithdrawalRequestsApi - interface
 */
export interface WithdrawalRequestsApiInterface {
    /**
     * Retrieves a list of all withdrawal requests.
     * @summary Get all withdrawal requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchAllRequest(options?: RawAxiosRequestConfig): AxiosPromise<Array<WithdrawalRequest>>;

    /**
     * Retrieves a specific withdrawal request using its associated Quid.
     * @summary Get a withdrawal request by Quid
     * @param {WithdrawalRequestsApiFetchRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fetchRequest(requestParameters: WithdrawalRequestsApiFetchRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<WithdrawalRequest>;

    /**
     * Creates a new withdrawal request for a user.
     * @summary Initiate a withdrawal request
     * @param {WithdrawalRequestsApiInitiateRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initiateRequest(requestParameters: WithdrawalRequestsApiInitiateRequestRequest, options?: RawAxiosRequestConfig): AxiosPromise<QuiikaResponse>;

    /**
     * Updates an existing withdrawal request.
     * @summary Update a withdrawal request
     * @param {WithdrawalRequestsApiInitiateRequest1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    initiateRequest1(requestParameters: WithdrawalRequestsApiInitiateRequest1Request, options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * Request parameters for fetchRequest operation in WithdrawalRequestsApi.
 */
export interface WithdrawalRequestsApiFetchRequestRequest {
    /**
     * The Quid associated with the withdrawal request.
     */
    readonly quid: string
}

/**
 * Request parameters for initiateRequest operation in WithdrawalRequestsApi.
 */
export interface WithdrawalRequestsApiInitiateRequestRequest {
    readonly withdrawalRequest: WithdrawalRequest
}

/**
 * Request parameters for initiateRequest1 operation in WithdrawalRequestsApi.
 */
export interface WithdrawalRequestsApiInitiateRequest1Request {
    readonly withdrawalUpdateDto: WithdrawalUpdateDto
}

/**
 * WithdrawalRequestsApi - object-oriented interface
 */
export class WithdrawalRequestsApi extends BaseAPI implements WithdrawalRequestsApiInterface {
    /**
     * Retrieves a list of all withdrawal requests.
     * @summary Get all withdrawal requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public fetchAllRequest(options?: RawAxiosRequestConfig) {
        return WithdrawalRequestsApiFp(this.configuration).fetchAllRequest(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a specific withdrawal request using its associated Quid.
     * @summary Get a withdrawal request by Quid
     * @param {WithdrawalRequestsApiFetchRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public fetchRequest(requestParameters: WithdrawalRequestsApiFetchRequestRequest, options?: RawAxiosRequestConfig) {
        return WithdrawalRequestsApiFp(this.configuration).fetchRequest(requestParameters.quid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new withdrawal request for a user.
     * @summary Initiate a withdrawal request
     * @param {WithdrawalRequestsApiInitiateRequestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public initiateRequest(requestParameters: WithdrawalRequestsApiInitiateRequestRequest, options?: RawAxiosRequestConfig) {
        return WithdrawalRequestsApiFp(this.configuration).initiateRequest(requestParameters.withdrawalRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates an existing withdrawal request.
     * @summary Update a withdrawal request
     * @param {WithdrawalRequestsApiInitiateRequest1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public initiateRequest1(requestParameters: WithdrawalRequestsApiInitiateRequest1Request, options?: RawAxiosRequestConfig) {
        return WithdrawalRequestsApiFp(this.configuration).initiateRequest1(requestParameters.withdrawalUpdateDto, options).then((request) => request(this.axios, this.basePath));
    }
}



